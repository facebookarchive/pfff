(* Yoann Padioleau
 *
 * Copyright (C) 2010 Facebook
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation, with the
 * special exception on linking described in file license.txt.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file
 * license.txt for more details.
 *)

(* generated by ocamltarzan: ocamltarzan -choice vof ast_js.ml *)

(* pad: few tweaks because of module limitations in ocamltarzan. *)

open Ast_js
module M = Meta_ast_generic
module Ast = Ast_js

let _current_precision = ref M.default_precision


let rec vof_info x =
  if !_current_precision.M.full_info
  then Parse_info.vof_info x
  else if !_current_precision.M.token_info
       then
        Ocaml.VDict [
          "line", Ocaml.VInt (PI.line_of_info x);
          "col", Ocaml.VInt (PI.col_of_info x);
        ]
      else Ocaml.VUnit

and vof_tok v = vof_info v
and vof_wrap _of_a (v1, v2) =
  let v1 = _of_a v1 and v2 = vof_info v2 in Ocaml.VTuple [ v1; v2 ]
and vof_paren _of_a (v1, v2, v3) =
  if !_current_precision.M.token_info then
  let v1 = vof_tok v1
  and v2 = _of_a v2
  and v3 = vof_tok v3
  in Ocaml.VTuple [ v1; v2; v3 ]
  else _of_a v2
and vof_brace _of_a (v1, v2, v3) =
  if !_current_precision.M.token_info then
  let v1 = vof_tok v1
  and v2 = _of_a v2
  and v3 = vof_tok v3
  in Ocaml.VTuple [ v1; v2; v3 ]
  else _of_a v2
and vof_bracket _of_a (v1, v2, v3) =
  if !_current_precision.M.token_info then
  let v1 = vof_tok v1
  and v2 = _of_a v2
  and v3 = vof_tok v3
  in Ocaml.VTuple [ v1; v2; v3 ]
  else _of_a v2
and vof_angle _of_a (v1, v2, v3) =
  let v1 = vof_tok v1
  and v2 = _of_a v2
  and v3 = vof_tok v3
  in Ocaml.VTuple [ v1; v2; v3 ]
and vof_comma_list _of_a xs =
  if !_current_precision.M.token_info
  then Ocaml.vof_list (Ocaml.vof_either _of_a vof_tok) xs
  else Ocaml.vof_list _of_a (Ast.uncomma xs)

and vof_sc v = Ocaml.vof_option vof_tok v

let vof_name v = vof_wrap Ocaml.vof_string v

let rec vof_expr =
  function
  | L v1 -> let v1 = vof_litteral v1 in Ocaml.VSum (("L", [ v1 ]))
  | V v1 -> let v1 = vof_name v1 in Ocaml.VSum (("V", [ v1 ]))
  | This v1 -> let v1 = vof_tok v1 in Ocaml.VSum (("This", [ v1 ]))
  | U ((v1, v2)) ->
      let v1 = vof_wrap vof_unop v1
      and v2 = vof_expr v2
      in Ocaml.VSum (("U", [ v1; v2 ]))
  | B ((v1, v2, v3)) ->
      let v1 = vof_expr v1
      and v2 = vof_wrap vof_binop v2
      and v3 = vof_expr v3
      in Ocaml.VSum (("B", [ v1; v2; v3 ]))
  | Bracket ((v1, v2)) ->
      let v1 = vof_expr v1
      and v2 = vof_bracket vof_expr v2
      in Ocaml.VSum (("Bracket", [ v1; v2 ]))
  | Period ((v1, v2, v3)) ->
      let v1 = vof_expr v1
      and v2 = vof_tok v2
      and v3 = vof_name v3
      in Ocaml.VSum (("Period", [ v1; v2; v3 ]))
  | Object v1 ->
      let v1 =
        vof_brace
          (vof_comma_list
             (function
             | P_field (v1, v2, v3) ->
                 let v1 = vof_property_name v1
                 and v2 = vof_tok v2
                 and v3 = vof_expr v3
                 in Ocaml.VSum (("P_field", [ v1; v2; v3 ]))
             | P_method v1 ->
                 let v1 = vof_func_decl v1
                 in Ocaml.VSum (("P_method", [v1]))))
          v1
      in Ocaml.VSum (("Object", [ v1 ]))
  | Array v1 ->
      let v1 = vof_bracket (vof_comma_list vof_expr) v1
      in Ocaml.VSum (("Array", [ v1 ]))
  | Apply ((v1, v2)) ->
      let v1 = vof_expr v1
      and v2 = vof_paren (vof_comma_list vof_expr) v2
      in Ocaml.VSum (("Apply", [ v1; v2 ]))
  | Conditional ((v1, v2, v3, v4, v5)) ->
      let v1 = vof_expr v1
      and v2 = vof_tok v2
      and v3 = vof_expr v3
      and v4 = vof_tok v4
      and v5 = vof_expr v5
      in Ocaml.VSum (("Conditional", [ v1; v2; v3; v4; v5 ]))
  | Assign ((v1, v2, v3)) ->
      let v1 = vof_expr v1
      and v2 = vof_wrap vof_assignment_operator v2
      and v3 = vof_expr v3
      in Ocaml.VSum (("Assign", [ v1; v2; v3 ]))
  | Seq ((v1, v2, v3)) ->
      let v1 = vof_expr v1
      and v2 = vof_tok v2
      and v3 = vof_expr v3
      in Ocaml.VSum (("Seq", [ v1; v2; v3 ]))
  | Function v1 ->
      let v1 = vof_func_decl v1 in Ocaml.VSum (("Function", [ v1 ]))
  | Arrow v1 -> let v1 = vof_arrow_func v1 in Ocaml.VSum (("Arrow", [ v1 ]))
  | Paren v1 ->
      let v1 = vof_paren vof_expr v1 in Ocaml.VSum (("Paren", [ v1 ]))
  | XhpHtml v1 ->
      let v1 = vof_xhp_html v1 in Ocaml.VSum (("XhpHtml", [ v1 ]))
  | Encaps ((v1, v2, v3, v4)) ->
      let v1 = Ocaml.vof_option vof_name v1
      and v2 = vof_tok v2
      and v3 = Ocaml.vof_list vof_encaps v3
      and v4 = vof_tok v4
      in Ocaml.VSum (("Encaps", [ v1; v2; v3; v4 ]))

and vof_litteral =
  function
  | Bool v1 ->
      let v1 = vof_wrap Ocaml.vof_bool v1 in Ocaml.VSum (("Bool", [ v1 ]))
  | Num v1 ->
      let v1 = vof_wrap Ocaml.vof_string v1 in Ocaml.VSum (("Num", [ v1 ]))
  | String v1 ->
      let v1 = vof_wrap Ocaml.vof_string v1
      in Ocaml.VSum (("String", [ v1 ]))
  | Regexp v1 ->
      let v1 = vof_wrap Ocaml.vof_string v1
      in Ocaml.VSum (("Regexp", [ v1 ]))
  | Null v1 -> let v1 = vof_tok v1 in Ocaml.VSum (("Null", [ v1 ]))
  | Undefined -> Ocaml.VSum (("Undefined", []))
and vof_unop =
  function
  | U_new -> Ocaml.VSum (("U_new", []))
  | U_delete -> Ocaml.VSum (("U_delete", []))
  | U_void -> Ocaml.VSum (("U_void", []))
  | U_typeof -> Ocaml.VSum (("U_typeof", []))
  | U_bitnot -> Ocaml.VSum (("U_bitnot", []))
  | U_pre_increment -> Ocaml.VSum (("U_pre_increment", []))
  | U_pre_decrement -> Ocaml.VSum (("U_pre_decrement", []))
  | U_post_increment -> Ocaml.VSum (("U_post_increment", []))
  | U_post_decrement -> Ocaml.VSum (("U_post_decrement", []))
  | U_plus -> Ocaml.VSum (("U_plus", []))
  | U_minus -> Ocaml.VSum (("U_minus", []))
  | U_not -> Ocaml.VSum (("U_not", []))
  | U_spread -> Ocaml.VSum (("U_spread", []))
and vof_binop =
  function
  | B_instanceof -> Ocaml.VSum (("B_instanceof", []))
  | B_in -> Ocaml.VSum (("B_in", []))
  | B_mul -> Ocaml.VSum (("B_mul", []))
  | B_div -> Ocaml.VSum (("B_div", []))
  | B_mod -> Ocaml.VSum (("B_mod", []))
  | B_add -> Ocaml.VSum (("B_add", []))
  | B_sub -> Ocaml.VSum (("B_sub", []))
  | B_le -> Ocaml.VSum (("B_le", []))
  | B_ge -> Ocaml.VSum (("B_ge", []))
  | B_lt -> Ocaml.VSum (("B_lt", []))
  | B_gt -> Ocaml.VSum (("B_gt", []))
  | B_lsr -> Ocaml.VSum (("B_lsr", []))
  | B_asr -> Ocaml.VSum (("B_asr", []))
  | B_lsl -> Ocaml.VSum (("B_lsl", []))
  | B_equal -> Ocaml.VSum (("B_equal", []))
  | B_notequal -> Ocaml.VSum (("B_notequal", []))
  | B_physequal -> Ocaml.VSum (("B_physequal", []))
  | B_physnotequal -> Ocaml.VSum (("B_physnotequal", []))
  | B_bitand -> Ocaml.VSum (("B_bitand", []))
  | B_bitor -> Ocaml.VSum (("B_bitor", []))
  | B_bitxor -> Ocaml.VSum (("B_bitxor", []))
  | B_and -> Ocaml.VSum (("B_and", []))
  | B_or -> Ocaml.VSum (("B_or", []))
and vof_property_name =
  function
  | PN_String v1 ->
      let v1 = vof_wrap Ocaml.vof_string v1
      in Ocaml.VSum (("PN_String", [ v1 ]))
  | PN_Num v1 ->
      let v1 = vof_wrap Ocaml.vof_string v1
      in Ocaml.VSum (("PN_Num", [ v1 ]))
and vof_assignment_operator =
  function
  | A_eq -> Ocaml.VSum (("A_eq", []))
  | A_mul -> Ocaml.VSum (("A_mul", []))
  | A_div -> Ocaml.VSum (("A_div", []))
  | A_mod -> Ocaml.VSum (("A_mod", []))
  | A_add -> Ocaml.VSum (("A_add", []))
  | A_sub -> Ocaml.VSum (("A_sub", []))
  | A_lsl -> Ocaml.VSum (("A_lsl", []))
  | A_lsr -> Ocaml.VSum (("A_lsr", []))
  | A_asr -> Ocaml.VSum (("A_asr", []))
  | A_and -> Ocaml.VSum (("A_and", []))
  | A_xor -> Ocaml.VSum (("A_xor", []))
  | A_or -> Ocaml.VSum (("A_or", []))
and vof_xhp_tag x = Ocaml.vof_string x
and vof_xhp_html =
  function
  | Xhp ((v1, v2, v3, v4, v5)) ->
      let v1 = vof_wrap vof_xhp_tag v1
      and v2 = Ocaml.vof_list vof_xhp_attribute v2
      and v3 = vof_tok v3
      and v4 = Ocaml.vof_list vof_xhp_body v4
      and v5 = vof_wrap (Ocaml.vof_option vof_xhp_tag) v5
      in Ocaml.VSum (("Xhp", [ v1; v2; v3; v4; v5 ]))
  | XhpSingleton ((v1, v2, v3)) ->
      let v1 = vof_wrap vof_xhp_tag v1
      and v2 = Ocaml.vof_list vof_xhp_attribute v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("XhpSingleton", [ v1; v2; v3 ]))
and vof_xhp_attribute (v1, v2, v3) =
  let v1 = vof_xhp_attr_name v1
  and v2 = vof_tok v2
  and v3 = vof_xhp_attr_value v3
  in Ocaml.VTuple [ v1; v2; v3 ]
and vof_xhp_attr_name v = vof_wrap Ocaml.vof_string v
and vof_xhp_attr_value =
  function
  | XhpAttrString v1 ->
      let v1 = vof_wrap Ocaml.vof_string v1
      in Ocaml.VSum (("XhpAttrString", [ v1 ]))
  | XhpAttrExpr v1 ->
      let v1 = vof_brace vof_expr v1 in Ocaml.VSum (("XhpAttrExpr", [ v1 ]))
and vof_xhp_body =
  function
  | XhpText v1 ->
      let v1 = vof_wrap Ocaml.vof_string v1
      in Ocaml.VSum (("XhpText", [ v1 ]))
  | XhpExpr v1 ->
      let v1 = vof_brace (Ocaml.vof_option vof_expr) v1 in Ocaml.VSum (("XhpExpr", [ v1 ]))
  | XhpNested v1 ->
      let v1 = vof_xhp_html v1 in Ocaml.VSum (("XhpNested", [ v1 ]))
and vof_encaps =
  function
  | EncapsString v1 ->
      let v1 = vof_wrap Ocaml.vof_string v1
      in Ocaml.VSum (("EncapsString", [ v1 ]))
  | EncapsExpr ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_expr v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("EncapsExpr", [ v1; v2; v3 ]))

and vof_st =
  function
  | Variable ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_comma_list vof_variable_declaration v2
      and v3 = vof_sc v3
      in Ocaml.VSum (("Variable", [ v1; v2; v3 ]))
  | Const ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_comma_list vof_variable_declaration v2
      and v3 = vof_sc v3
      in Ocaml.VSum (("Const", [ v1; v2; v3 ]))
  | Block v1 ->
      let v1 = vof_brace (Ocaml.vof_list vof_toplevel) v1
      in Ocaml.VSum (("Block", [ v1 ]))
  | Nop v1 -> let v1 = vof_sc v1 in Ocaml.VSum (("Nop", [ v1 ]))
  | ExprStmt ((v1, v2)) ->
      let v1 = vof_expr v1
      and v2 = vof_sc v2
      in Ocaml.VSum (("ExprStmt", [ v1; v2 ]))
  | If ((v1, v2, v3, v4)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren vof_expr v2
      and v3 = vof_st v3
      and v4 =
        Ocaml.vof_option
          (fun (v1, v2) ->
             let v1 = vof_tok v1
             and v2 = vof_st v2
             in Ocaml.VTuple [ v1; v2 ])
          v4
      in Ocaml.VSum (("If", [ v1; v2; v3; v4 ]))
  | Do ((v1, v2, v3, v4, v5)) ->
      let v1 = vof_tok v1
      and v2 = vof_st v2
      and v3 = vof_tok v3
      and v4 = vof_paren vof_expr v4
      and v5 = vof_sc v5
      in Ocaml.VSum (("Do", [ v1; v2; v3; v4; v5 ]))
  | While ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren vof_expr v2
      and v3 = vof_st v3
      in Ocaml.VSum (("While", [ v1; v2; v3 ]))
  | For ((v1, v2, v3, v4, v5, v6, v7, v8, v9)) ->
      let v1 = vof_tok v1
      and v2 = vof_tok v2
      and v3 = Ocaml.vof_option vof_lhs_or_var v3
      and v4 = vof_tok v4
      and v5 = Ocaml.vof_option vof_expr v5
      and v6 = vof_tok v6
      and v7 = Ocaml.vof_option vof_expr v7
      and v8 = vof_tok v8
      and v9 = vof_st v9
      in Ocaml.VSum (("For", [ v1; v2; v3; v4; v5; v6; v7; v8; v9 ]))
  | ForIn ((v1, v2, v3, v4, v5, v6, v7)) ->
      let v1 = vof_tok v1
      and v2 = vof_tok v2
      and v3 = vof_lhs_or_var v3
      and v4 = vof_tok v4
      and v5 = vof_expr v5
      and v6 = vof_tok v6
      and v7 = vof_st v7
      in Ocaml.VSum (("ForIn", [ v1; v2; v3; v4; v5; v6; v7 ]))
  | Switch ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren vof_expr v2
      and v3 = vof_brace (Ocaml.vof_list vof_case_clause) v3
      in Ocaml.VSum (("Switch", [ v1; v2; v3 ]))
  | Continue ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = Ocaml.vof_option vof_label v2
      and v3 = vof_sc v3
      in Ocaml.VSum (("Continue", [ v1; v2; v3 ]))
  | Break ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = Ocaml.vof_option vof_label v2
      and v3 = vof_sc v3
      in Ocaml.VSum (("Break", [ v1; v2; v3 ]))
  | Return ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = Ocaml.vof_option vof_expr v2
      and v3 = vof_sc v3
      in Ocaml.VSum (("Return", [ v1; v2; v3 ]))
  | With ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren vof_expr v2
      and v3 = vof_st v3
      in Ocaml.VSum (("With", [ v1; v2; v3 ]))
  | Labeled ((v1, v2, v3)) ->
      let v1 = vof_label v1
      and v2 = vof_tok v2
      and v3 = vof_st v3
      in Ocaml.VSum (("Labeled", [ v1; v2; v3 ]))
  | Throw ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_expr v2
      and v3 = vof_sc v3
      in Ocaml.VSum (("Throw", [ v1; v2; v3 ]))
  | Try ((v1, v2, v3, v4)) ->
      let v1 = vof_tok v1
      and v2 = vof_st v2
      and v3 =
        Ocaml.vof_option
          (fun (v1, v2, v3) ->
             let v1 = vof_tok v1
             and v2 = vof_paren vof_arg v2
             and v3 = vof_st v3
             in Ocaml.VTuple [ v1; v2; v3 ])
          v3
      and v4 =
        Ocaml.vof_option
          (fun (v1, v2) ->
             let v1 = vof_tok v1
             and v2 = vof_st v2
             in Ocaml.VTuple [ v1; v2 ])
          v4
      in Ocaml.VSum (("Try", [ v1; v2; v3; v4 ]))
and vof_label v = vof_wrap Ocaml.vof_string v
and vof_lhs_or_var =
  function
  | LHS v1 -> let v1 = vof_expr v1 in Ocaml.VSum (("LHS", [ v1 ]))
  | Vars ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_comma_list vof_variable_declaration v2
      in Ocaml.VSum (("Vars", [ v1; v2 ]))
and vof_case_clause =
  function
  | Default ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_tok v2
      and v3 = Ocaml.vof_list vof_toplevel v3
      in Ocaml.VSum (("Default", [ v1; v2; v3 ]))
  | Case ((v1, v2, v3, v4)) ->
      let v1 = vof_tok v1
      and v2 = vof_expr v2
      and v3 = vof_tok v3
      and v4 = Ocaml.vof_list vof_toplevel v4
      in Ocaml.VSum (("Case", [ v1; v2; v3; v4 ]))
and vof_arg v = vof_wrap Ocaml.vof_string v
and vof_type_ =
  function
  | TName v1 ->
      let v1 = vof_nominal_type v1 in
      Ocaml.VSum (("TName", [ v1 ]))
  | TQuestion ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_type_ v2
      in Ocaml.VSum (("TQuestion", [ v1; v2 ]))
  | TFun ((v1, v2, v3)) ->
      let v1 =
        vof_paren
          (vof_comma_list
             (fun (v1, v2) ->
               let v1 = vof_param_name v1
               and v2 = vof_annotation v2
               in Ocaml.VTuple [ v1; v2 ]))
          v1
      and v2 = vof_tok v2
      and v3 = vof_type_ v3
      in Ocaml.VSum (("TFun", [ v1; v2; v3 ]))
  | TObj v1 ->
      let v1 =
        vof_brace
          (Ocaml.vof_list
             (fun (v1, v2, v3) ->
                let v1 = vof_name v1
                and v2 = vof_annotation v2
                and v3 = vof_sc v3
                in Ocaml.VTuple [ v1; v2; v3 ]))
          v1
      in Ocaml.VSum (("TObj", [ v1 ]))
and vof_param_name = function
  | RequiredParam(v1) ->
      let v1 = vof_name v1
      in Ocaml.VSum (("RequiredParam", [v1]))
  | OptionalParam(v1,v2) ->
      let v1 = vof_name v1
      and v2 = vof_tok v2
      in Ocaml.VSum (("OptionalParam", [v1; v2]))
  | RestParam(v1,v2) ->
      let v1 = vof_tok v1
      and v2 = vof_name v2
      in Ocaml.VSum (("RestParam", [v1; v2]))

and vof_annotation = function
  | TAnnot(v1, v2) ->
      let v1 = vof_tok v1
      and v2 = vof_type_ v2
      in Ocaml.VSum (("TAnnot", [v1; v2]))
  | TFunAnnot(v1,v2,v3,v4) ->
      let v1 = Ocaml.vof_option
        (vof_angle (vof_comma_list vof_name)) v1 in
      let v2 =
        vof_paren
          (vof_comma_list
             (fun (v1, v2) ->
               let v1 = vof_param_name v1
               and v2 = vof_annotation v2
               in Ocaml.VTuple [ v1; v2 ]))
          v2
      and v3 = vof_tok v3
      and v4 = vof_type_ v4
      in Ocaml.VSum (("TFunAnnot", [ v1; v2; v3; v4 ]))

and vof_nominal_type ((v1,v2)) =
  let v1 = vof_expr v1 in
  let v2 = Ocaml.vof_option (vof_angle (vof_comma_list vof_type_)) v2 in
  Ocaml.VTuple [ v1; v2 ]
and vof_type_opt v =
  Ocaml.vof_option vof_annotation v
and
  vof_func_decl {
                  f_tok = v_f_tok;
                  f_name = v_f_name;
                  f_params = v_f_params;
                  f_type_params = v_f_type_params;
                  f_return_type = v_f_return_type;
                  f_body = v_f_body
                } =
  let bnds = [] in
  let arg = vof_brace (Ocaml.vof_list vof_toplevel) v_f_body in
  let bnd = ("f_body", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_type_opt v_f_return_type in
  let bnd = ("f_return_type", arg) in
  let bnds = bnd :: bnds in
  let arg =
    Ocaml.vof_option
      (vof_angle (vof_comma_list vof_name)) v_f_type_params
  in
  let bnd = ("f_type_params", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_paren (vof_comma_list vof_parameter) v_f_params in
  let bnd = ("f_params", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_option vof_name v_f_name in
  let bnd = ("f_name", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_option vof_tok v_f_tok in
  let bnd = ("f_tok", arg) in
  let bnds = bnd :: bnds in
  Ocaml.VDict bnds
and vof_parameter { p_name = v_p_name; p_type = v_p_type; p_default = v_default;
  p_dots = v_dots } =
  let bnds = [] in
  let arg = vof_type_opt v_p_type in
  let bnd = ("p_type", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_name v_p_name in
  let bnd = ("p_name", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_option vof_default v_default in
  let bnd = ("p_default", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_option vof_tok v_dots in
  let bnd = ("p_dots", arg) in
  let bnds = bnd :: bnds in
  Ocaml.VDict bnds
and vof_default = function
  | DNone (v1) -> let v1 = vof_tok v1 in Ocaml.VSum (("DNone", [v1]))
  | DSome (v1,v2) -> let v1 = vof_tok v1 and v2 = vof_expr v2 in Ocaml.VSum (("DSome", [v1; v2]))
and
  vof_arrow_func { a_params = v_a_params; a_return_type = v_a_return_type;
                   a_tok = v_a_tok; a_body = v_a_body
                 } =
  let bnds = [] in
  let arg = vof_arrow_body v_a_body in
  let bnd = ("a_body", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_tok v_a_tok in
  let bnd = ("a_tok", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_type_opt v_a_return_type in
  let bnd = ("a_return_type", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_arrow_params v_a_params in
  let bnd = ("a_params", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_arrow_params =
  function
  | ASingleParam v1 ->
      let v1 = vof_parameter v1 in Ocaml.VSum (("ASingleParam", [ v1 ]))
  | AParams v1 ->
      let v1 = vof_paren (vof_comma_list vof_parameter) v1
      in Ocaml.VSum (("AParams", [ v1 ]))
and vof_arrow_body =
  function
  | AExpr v1 -> let v1 = vof_expr v1 in Ocaml.VSum (("AExpr", [ v1 ]))
  | ABody v1 ->
      let v1 = vof_brace (Ocaml.vof_list vof_toplevel) v1
      in Ocaml.VSum (("ABody", [ v1 ]))
and
  vof_variable_declaration {
                             v_name = v_v_name;
                             v_init = v_v_init;
                             v_type = v_v_type
                           } =
  let bnds = [] in
  let arg = vof_type_opt v_v_type in
  let bnd = ("v_type", arg) in
  let bnds = bnd :: bnds in
  let arg =
    Ocaml.vof_option
      (fun (v1, v2) ->
         let v1 = vof_tok v1 and v2 = vof_expr v2 in Ocaml.VTuple [ v1; v2 ])
      v_v_init in
  let bnd = ("v_init", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_name v_v_name in
  let bnd = ("v_name", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds

and vof_toplevel =
  function
  | St v1 -> let v1 = vof_st v1 in Ocaml.VSum (("St", [ v1 ]))
  | FunDecl v1 ->
      let v1 = vof_func_decl v1 in Ocaml.VSum (("FunDecl", [ v1 ]))
  | ClassDecl v1 ->
      let v1 = vof_class_decl v1 in Ocaml.VSum (("ClassDecl", [ v1 ]))
  | InterfaceDecl v1 ->
      let v1 = vof_interface_decl v1 in Ocaml.VSum (("InterfaceDecl", [ v1 ]))

and  vof_class_decl {
                   c_tok = v_c_tok;
                   c_name = v_c_name;
                   c_type_params = v_c_type_params;
                   c_extends = v_c_extends;
                   c_body = v_c_body
                 } =
  let bnds = [] in
  let arg = vof_brace (Ocaml.vof_list vof_class_stmt) v_c_body in
  let bnd = ("c_body", arg) in
  let bnds = bnd :: bnds in
  let arg =
    Ocaml.vof_option
      (fun (v1, v2) ->
         let v1 = vof_tok v1
         and v2 = vof_nominal_type v2
         in Ocaml.VTuple [ v1; v2 ])
      v_c_extends in
  let bnd = ("c_extends", arg) in
  let bnds = bnd :: bnds in
  let arg =
    Ocaml.vof_option
      (vof_angle (vof_comma_list vof_name)) v_c_type_params
  in
  let bnd = ("c_type_params", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_name v_c_name in
  let bnd = ("c_name", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_tok v_c_tok in
  let bnd = ("c_tok", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and  vof_interface_decl {
                   i_tok = v_i_tok;
                   i_name = v_i_name;
                   i_type_params = v_i_type_params;
                   i_type = v_i_type;
                 } =
  let bnds = [] in
  let arg = vof_type_ v_i_type in
  let bnd = ("i_type", arg) in
  let bnds = bnd :: bnds in
  let arg =
    Ocaml.vof_option
      (vof_angle (vof_comma_list vof_name)) v_i_type_params
  in
  let bnd = ("i_type_params", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_name v_i_name in
  let bnd = ("i_name", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_tok v_i_tok in
  let bnd = ("i_tok", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds

and vof_class_stmt =
  function
  | Field ((v1, v2, v3)) ->
      let v1 = vof_name v1
      and v2 = vof_annotation v2
      and v3 = vof_sc v3
      in Ocaml.VSum (("Field", [ v1; v2; v3 ]))
  | Method ((v1, v2)) ->
      let v1 = Ocaml.vof_option vof_tok v1
      and v2 = vof_func_decl v2
      in Ocaml.VSum (("Method", [ v1; v2 ]))
  | ClassExtraSemiColon v1 ->
      let v1 = vof_sc v1 in Ocaml.VSum (("ClassExtraSemiColon", [ v1 ]))

and vof_program_orig v = Ocaml.vof_list vof_toplevel v

let vof_any_orig =
  function
  | Expr v1 -> let v1 = vof_expr v1 in Ocaml.VSum (("Expr", [ v1 ]))
  | Stmt v1 -> let v1 = vof_st v1 in Ocaml.VSum (("Stmt", [ v1 ]))
  | Func v1 -> let v1 = vof_func_decl v1 in Ocaml.VSum (("Func", [ v1 ]))
  | Toplevel v1 ->
      let v1 = vof_toplevel v1 in Ocaml.VSum (("Toplevel", [ v1 ]))
  | Program v1 -> let v1 = vof_program_orig v1 in Ocaml.VSum (("Program", [ v1 ]))


(* end auto generation *)

let vof_any ?(precision=M.default_precision) x =
  Common.save_excursion _current_precision precision (fun () ->
    vof_any_orig x
  )

let vof_program ?(precision=M.default_precision) x =
  Common.save_excursion _current_precision precision (fun () ->
    vof_program_orig x
  )
