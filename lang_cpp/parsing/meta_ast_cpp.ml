(* Yoann Padioleau
 *
 * Copyright (C) 2010 Facebook
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation, with the
 * special exception on linking described in file license.txt.
 * 
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file
 * license.txt for more details.
 *)

(* generated by ocamltarzan: ocamltarzan -choice vof ast_cpp.ml *)

open Ast_cpp
module Ast = Ast_cpp
module M = Meta_ast_generic

(* todo? could also do via a post processing phase with a OCaml.map_v ? *)
let _current_precision = ref M.default_precision

let rec vof_info x = 
  if !_current_precision.M.full_info
  then Parse_info.vof_info x
  else if !_current_precision.M.token_info
       then 
        Ocaml.VDict [
          "line", Ocaml.VInt (Parse_info.line_of_info x);
          "col", Ocaml.VInt (Parse_info.col_of_info x);
        ]
      else Ocaml.VUnit

and vof_tok v = vof_info v
and vof_wrap _of_a (v1, v2) =
  let v1 = _of_a v1
  and v2 = Ocaml.vof_list vof_info v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_wrap2 _of_a (v1, v2) =
  let v1 = _of_a v1 and v2 = vof_info v2 in Ocaml.VTuple [ v1; v2 ]

and vof_paren _of_a (v1, v2, v3) =
  if !_current_precision.M.token_info then
  let v1 = vof_tok v1
  and v2 = _of_a v2
  and v3 = vof_tok v3
  in Ocaml.VTuple [ v1; v2; v3 ]
  else _of_a v2
and vof_brace _of_a (v1, v2, v3) =
  if !_current_precision.M.token_info then
  let v1 = vof_tok v1
  and v2 = _of_a v2
  and v3 = vof_tok v3
  in Ocaml.VTuple [ v1; v2; v3 ]
  else _of_a v2
and vof_bracket _of_a (v1, v2, v3) =
  if !_current_precision.M.token_info then
  let v1 = vof_tok v1
  and v2 = _of_a v2
  and v3 = vof_tok v3
  in Ocaml.VTuple [ v1; v2; v3 ]
  else _of_a v2
and vof_angle _of_a (v1, v2, v3) =
  let v1 = vof_tok v1
  and v2 = _of_a v2
  and v3 = vof_tok v3
  in Ocaml.VTuple [ v1; v2; v3 ]

and vof_comma_list _of_a  xs= 
  if !_current_precision.M.token_info
  then Ocaml.vof_list (vof_wrap _of_a) xs
  else Ocaml.vof_list _of_a (Ast.uncomma xs)

and vof_comma_list2 _of_a = Ocaml.vof_list (Ocaml.vof_either _of_a vof_tok)


let rec vof_name (v1, v2, v3) =
  let v1 = Ocaml.vof_option vof_tok v1
  and v2 =
    Ocaml.vof_list
      (fun (v1, v2) ->
         let v1 = vof_qualifier v1
         and v2 = vof_tok v2
         in Ocaml.VTuple [ v1; v2 ])
      v2
  and v3 = vof_ident v3
  in Ocaml.VTuple [ v1; v2; v3 ]
and vof_ident =
  function
  | IdIdent v1 ->
      let v1 = vof_wrap2 Ocaml.vof_string v1
      in Ocaml.VSum (("IdIdent", [ v1 ]))
  | IdOperator ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 =
        (match v2 with
         | (v1, v2) ->
             let v1 = vof_operator v1
             and v2 = Ocaml.vof_list vof_tok v2
             in Ocaml.VTuple [ v1; v2 ])
      in Ocaml.VSum (("IdOperator", [ v1; v2 ]))
  | IdConverter ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_fullType v2
      in Ocaml.VSum (("IdConverter", [ v1; v2 ]))
  | IdDestructor ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_wrap2 Ocaml.vof_string v2
      in Ocaml.VSum (("IdDestructor", [ v1; v2 ]))
  | IdTemplateId ((v1, v2)) ->
      let v1 = vof_wrap2 Ocaml.vof_string v1
      and v2 = vof_template_arguments v2
      in Ocaml.VSum (("IdTemplateId", [ v1; v2 ]))
and vof_template_arguments v =
  vof_angle (vof_comma_list vof_template_argument) v
and vof_template_argument v = Ocaml.vof_either vof_fullType vof_expression v
and vof_qualifier =
  function
  | QClassname v1 ->
      let v1 = vof_wrap2 Ocaml.vof_string v1
      in Ocaml.VSum (("QClassname", [ v1 ]))
  | QTemplateId ((v1, v2)) ->
      let v1 = vof_wrap2 Ocaml.vof_string v1
      and v2 = vof_template_arguments v2
      in Ocaml.VSum (("QTemplateId", [ v1; v2 ]))
and vof_class_name v = vof_name v
and vof_namespace_name v = vof_name v
and vof_ident_name v = vof_name v

and vof_either_ft_or_expr v = Ocaml.vof_either vof_fullType vof_expression v


and vof_fullType (v1, v2) =
  let v1 = vof_typeQualifier v1
  and v2 = vof_typeC v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_typeC v = vof_wrap vof_typeCbis v
and vof_typeCbis =
  function
  | BaseType v1 ->
      let v1 = vof_baseType v1 in Ocaml.VSum (("BaseType", [ v1 ]))
  | Pointer v1 ->
      let v1 = vof_fullType v1 in Ocaml.VSum (("Pointer", [ v1 ]))
  | Reference v1 ->
      let v1 = vof_fullType v1 in Ocaml.VSum (("Reference", [ v1 ]))
  | Array ((v1, v2)) ->
      let v1 = vof_bracket (Ocaml.vof_option vof_constExpression) v1
      and v2 = vof_fullType v2
      in Ocaml.VSum (("Array", [ v1; v2 ]))
  | FunctionType v1 ->
      let v1 = vof_functionType v1 in Ocaml.VSum (("FunctionType", [ v1 ]))
  | EnumDef ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = Ocaml.vof_option (vof_wrap2 Ocaml.vof_string) v2
      and v3 = vof_brace (vof_comma_list vof_enum_elem) v3
      in Ocaml.VSum (("EnumDed", [ v1; v2; v3 ]))
  | StructDef v1 ->
      let v1 = vof_class_definition v1
      in Ocaml.VSum (("StructDef", [ v1 ]))
  | EnumName ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_wrap2 Ocaml.vof_string v2
      in Ocaml.VSum (("EnumName", [ v1; v2 ]))
  | StructUnionName ((v1, v2)) ->
      let v1 = vof_wrap2 vof_structUnion v1
      and v2 = vof_wrap2 Ocaml.vof_string v2
      in Ocaml.VSum (("StructUnionName", [ v1; v2 ]))
  | TypeName ((v1)) ->
      let v1 = vof_name v1
      in Ocaml.VSum (("TypeName", [ v1 ]))
  | TypenameKwd ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_name v2
      in Ocaml.VSum (("TypenameKwd", [ v1; v2 ]))
  | TypeOf ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren vof_either_ft_or_expr v2
      in Ocaml.VSum (("TypeOf", [ v1; v2 ]))
  | ParenType v1 ->
      let v1 = vof_paren vof_fullType v1
      in Ocaml.VSum (("ParenType", [ v1 ]))
and vof_baseType =
  function
  | Void -> Ocaml.VSum (("Void", []))
  | IntType v1 -> let v1 = vof_intType v1 in Ocaml.VSum (("IntType", [ v1 ]))
  | FloatType v1 ->
      let v1 = vof_floatType v1 in Ocaml.VSum (("FloatType", [ v1 ]))
and vof_intType =
  function
  | CChar -> Ocaml.VSum (("CChar", []))
  | Si v1 -> let v1 = vof_signed v1 in Ocaml.VSum (("Si", [ v1 ]))
  | CBool -> Ocaml.VSum (("CBool", []))
  | WChar_t -> Ocaml.VSum (("WChar_t", []))
and vof_signed (v1, v2) =
  let v1 = vof_sign v1 and v2 = vof_base v2 in Ocaml.VTuple [ v1; v2 ]
and vof_base =
  function
  | CChar2 -> Ocaml.VSum (("CChar2", []))
  | CShort -> Ocaml.VSum (("CShort", []))
  | CInt -> Ocaml.VSum (("CInt", []))
  | CLong -> Ocaml.VSum (("CLong", []))
  | CLongLong -> Ocaml.VSum (("CLongLong", []))
and vof_sign =
  function
  | Signed -> Ocaml.VSum (("Signed", []))
  | UnSigned -> Ocaml.VSum (("UnSigned", []))
and vof_floatType =
  function
  | CFloat -> Ocaml.VSum (("CFloat", []))
  | CDouble -> Ocaml.VSum (("CDouble", []))
  | CLongDouble -> Ocaml.VSum (("CLongDouble", []))
and vof_enum_elem { e_name = v_e_name; e_val = v_e_val } =
  let bnds = [] in
  let arg =
    Ocaml.vof_option
      (fun (v1, v2) ->
         let v1 = vof_tok v1
         and v2 = vof_constExpression v2
         in Ocaml.VTuple [ v1; v2 ])
      v_e_val in
  let bnd = ("e_val", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_wrap2 Ocaml.vof_string v_e_name in
  let bnd = ("e_name", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds


and vof_typeQualifier { const = v_const; volatile = v_volatile } =
 if not !_current_precision.M.type_info
 then Ocaml.VUnit
 else
  let bnds = [] in
  let arg = Ocaml.vof_option vof_tok v_volatile in
  let bnd = ("volatile", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_option vof_tok v_const in
  let bnd = ("const", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds

and vof_expression v = vof_wrap vof_expressionbis v
and vof_expressionbis =
  function
  | Id ((v1, v2)) ->
      let v1 = vof_name v1
      and v2 = vof_ident_info v2
      in Ocaml.VSum (("Id", [ v1; v2 ]))
  | C v1 -> let v1 = vof_constant v1 in Ocaml.VSum (("C", [ v1 ]))
  | Call ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_paren (vof_comma_list vof_argument) v2
      in Ocaml.VSum (("Call", [ v1; v2 ]))
  | CondExpr ((v1, v2, v3)) ->
      let v1 = vof_expression v1
      and v2 = Ocaml.vof_option vof_expression v2
      and v3 = vof_expression v3
      in Ocaml.VSum (("CondExpr", [ v1; v2; v3 ]))
  | Sequence ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_expression v2
      in Ocaml.VSum (("Sequence", [ v1; v2 ]))
  | Assignment ((v1, v2, v3)) ->
      let v1 = vof_expression v1
      and v2 = vof_assignOp v2
      and v3 = vof_expression v3
      in Ocaml.VSum (("Assignment", [ v1; v2; v3 ]))
  | Postfix ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_fixOp v2
      in Ocaml.VSum (("Postfix", [ v1; v2 ]))
  | Infix ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_fixOp v2
      in Ocaml.VSum (("Infix", [ v1; v2 ]))
  | Unary ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_unaryOp v2
      in Ocaml.VSum (("Unary", [ v1; v2 ]))
  | Binary ((v1, v2, v3)) ->
      let v1 = vof_expression v1
      and v2 = vof_binaryOp v2
      and v3 = vof_expression v3
      in Ocaml.VSum (("Binary", [ v1; v2; v3 ]))
  | ArrayAccess ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_bracket vof_expression v2
      in Ocaml.VSum (("ArrayAccess", [ v1; v2 ]))
  | RecordAccess ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_name v2
      in Ocaml.VSum (("RecordAccess", [ v1; v2 ]))
  | RecordPtAccess ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_name v2
      in Ocaml.VSum (("RecordPtAccess", [ v1; v2 ]))
  | RecordStarAccess ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_expression v2
      in Ocaml.VSum (("RecordStarAccess", [ v1; v2 ]))
  | RecordPtStarAccess ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_expression v2
      in Ocaml.VSum (("RecordPtStarAccess", [ v1; v2 ]))
  | SizeOfExpr ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_expression v2
      in Ocaml.VSum (("SizeOfExpr", [ v1; v2 ]))
  | SizeOfType ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren vof_fullType v2
      in Ocaml.VSum (("SizeOfType", [ v1; v2 ]))
  | Cast ((v1, v2)) ->
      let v1 = vof_paren vof_fullType v1
      and v2 = vof_expression v2
      in Ocaml.VSum (("Cast", [ v1; v2 ]))
  | StatementExpr v1 ->
      let v1 = vof_paren vof_compound v1
      in Ocaml.VSum (("StatementExpr", [ v1 ]))
  | GccConstructor ((v1, v2)) ->
      let v1 = vof_paren vof_fullType v1
      and v2 = vof_brace (vof_comma_list vof_initialiser) v2
      in Ocaml.VSum (("GccConstructor", [ v1; v2 ]))
  | This v1 -> let v1 = vof_tok v1 in Ocaml.VSum (("This", [ v1 ]))
  | ConstructedObject ((v1, v2)) ->
      let v1 = vof_fullType v1
      and v2 = vof_paren (vof_comma_list vof_argument) v2
      in Ocaml.VSum (("ConstructedObject", [ v1; v2 ]))
  | TypeId ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren vof_either_ft_or_expr v2
      in Ocaml.VSum (("TypeId", [ v1; v2 ]))
  | CplusplusCast ((v1, v2, v3)) ->
      let v1 = vof_wrap2 vof_cast_operator v1
      and v2 = vof_angle vof_fullType v2
      and v3 = vof_paren vof_expression v3
      in Ocaml.VSum (("CplusplusCast", [ v1; v2; v3 ]))
  | New ((v1, v2, v3, v4, v5)) ->
      let v1 = Ocaml.vof_option vof_tok v1
      and v2 = vof_tok v2
      and v3 = Ocaml.vof_option (vof_paren (vof_comma_list vof_argument)) v3
      and v4 = vof_fullType v4
      and v5 = Ocaml.vof_option (vof_paren (vof_comma_list vof_argument)) v5
      in Ocaml.VSum (("New", [ v1; v2; v3; v4; v5 ]))
  | Delete ((v1, v2)) ->
      let v1 = Ocaml.vof_option vof_tok v1
      and v2 = vof_expression v2
      in Ocaml.VSum (("Delete", [ v1; v2 ]))
  | DeleteArray ((v1, v2)) ->
      let v1 = Ocaml.vof_option vof_tok v1
      and v2 = vof_expression v2
      in Ocaml.VSum (("DeleteArray", [ v1; v2 ]))
  | Throw v1 ->
      let v1 = Ocaml.vof_option vof_expression v1
      in Ocaml.VSum (("Throw", [ v1 ]))
  | ParenExpr v1 ->
      let v1 = vof_paren vof_expression v1
      in Ocaml.VSum (("ParenExpr", [ v1 ]))
  | ExprTodo -> Ocaml.VSum (("ExprTodo", []))
and vof_ident_info { i_scope = v_i_scope } =
  let bnds = [] in
  let arg = Scope_code.vof_scope v_i_scope in
  let bnd = ("i_scope", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_argument v = Ocaml.vof_either vof_expression vof_weird_argument v
and vof_weird_argument =
  function
  | ArgType v1 ->
      let v1 = vof_fullType v1 in Ocaml.VSum (("ArgType", [ v1 ]))
  | ArgAction v1 ->
      let v1 = vof_action_macro v1 in Ocaml.VSum (("ArgAction", [ v1 ]))
and vof_action_macro =
  function
  | ActMisc v1 ->
      let v1 = Ocaml.vof_list vof_tok v1 in Ocaml.VSum (("ActMisc", [ v1 ]))
and vof_constant =
  function
  | String v1 ->
      let v1 =
        (match v1 with
         | (v1, v2) ->
             let v1 = Ocaml.vof_string v1
             and v2 = vof_isWchar v2
             in Ocaml.VTuple [ v1; v2 ])
      in Ocaml.VSum (("String", [ v1 ]))
  | MultiString -> Ocaml.VSum (("MultiString", []))
  | Char v1 ->
      let v1 =
        (match v1 with
         | (v1, v2) ->
             let v1 = Ocaml.vof_string v1
             and v2 = vof_isWchar v2
             in Ocaml.VTuple [ v1; v2 ])
      in Ocaml.VSum (("Char", [ v1 ]))
  | Int v1 -> let v1 = Ocaml.vof_string v1 in Ocaml.VSum (("Int", [ v1 ]))
  | Float v1 ->
      let v1 =
        (match v1 with
         | (v1, v2) ->
             let v1 = Ocaml.vof_string v1
             and v2 = vof_floatType v2
             in Ocaml.VTuple [ v1; v2 ])
      in Ocaml.VSum (("Float", [ v1 ]))
  | Bool v1 -> let v1 = Ocaml.vof_bool v1 in Ocaml.VSum (("Bool", [ v1 ]))
and vof_isWchar =
  function
  | IsWchar -> Ocaml.VSum (("IsWchar", []))
  | IsChar -> Ocaml.VSum (("IsChar", []))
and vof_unaryOp =
  function
  | GetRef -> Ocaml.VSum (("GetRef", []))
  | DeRef -> Ocaml.VSum (("DeRef", []))
  | UnPlus -> Ocaml.VSum (("UnPlus", []))
  | UnMinus -> Ocaml.VSum (("UnMinus", []))
  | Tilde -> Ocaml.VSum (("Tilde", []))
  | Not -> Ocaml.VSum (("Not", []))
  | GetRefLabel -> Ocaml.VSum (("GetRefLabel", []))
and vof_assignOp =
  function
  | SimpleAssign -> Ocaml.VSum (("SimpleAssign", []))
  | OpAssign v1 ->
      let v1 = vof_arithOp v1 in Ocaml.VSum (("OpAssign", [ v1 ]))
and vof_fixOp =
  function
  | Dec -> Ocaml.VSum (("Dec", []))
  | Inc -> Ocaml.VSum (("Inc", []))
and vof_binaryOp =
  function
  | Arith v1 -> let v1 = vof_arithOp v1 in Ocaml.VSum (("Arith", [ v1 ]))
  | Logical v1 ->
      let v1 = vof_logicalOp v1 in Ocaml.VSum (("Logical", [ v1 ]))
and vof_arithOp =
  function
  | Plus -> Ocaml.VSum (("Plus", []))
  | Minus -> Ocaml.VSum (("Minus", []))
  | Mul -> Ocaml.VSum (("Mul", []))
  | Div -> Ocaml.VSum (("Div", []))
  | Mod -> Ocaml.VSum (("Mod", []))
  | DecLeft -> Ocaml.VSum (("DecLeft", []))
  | DecRight -> Ocaml.VSum (("DecRight", []))
  | And -> Ocaml.VSum (("And", []))
  | Or -> Ocaml.VSum (("Or", []))
  | Xor -> Ocaml.VSum (("Xor", []))
and vof_logicalOp =
  function
  | Inf -> Ocaml.VSum (("Inf", []))
  | Sup -> Ocaml.VSum (("Sup", []))
  | InfEq -> Ocaml.VSum (("InfEq", []))
  | SupEq -> Ocaml.VSum (("SupEq", []))
  | Eq -> Ocaml.VSum (("Eq", []))
  | NotEq -> Ocaml.VSum (("NotEq", []))
  | AndLog -> Ocaml.VSum (("AndLog", []))
  | OrLog -> Ocaml.VSum (("OrLog", []))
and vof_ptrOp =
  function
  | PtrStarOp -> Ocaml.VSum (("PtrStarOp", []))
  | PtrOp -> Ocaml.VSum (("PtrOp", []))
and vof_allocOp =
  function
  | NewOp -> Ocaml.VSum (("NewOp", []))
  | DeleteOp -> Ocaml.VSum (("DeleteOp", []))
  | NewArrayOp -> Ocaml.VSum (("NewArrayOp", []))
  | DeleteArrayOp -> Ocaml.VSum (("DeleteArrayOp", []))
and vof_accessop =
  function
  | ParenOp -> Ocaml.VSum (("ParenOp", []))
  | ArrayOp -> Ocaml.VSum (("ArrayOp", []))
and vof_operator =
  function
  | BinaryOp v1 ->
      let v1 = vof_binaryOp v1 in Ocaml.VSum (("BinaryOp", [ v1 ]))
  | AssignOp v1 ->
      let v1 = vof_assignOp v1 in Ocaml.VSum (("AssignOp", [ v1 ]))
  | FixOp v1 -> let v1 = vof_fixOp v1 in Ocaml.VSum (("FixOp", [ v1 ]))
  | PtrOpOp v1 -> let v1 = vof_ptrOp v1 in Ocaml.VSum (("PtrOpOp", [ v1 ]))
  | AccessOp v1 ->
      let v1 = vof_accessop v1 in Ocaml.VSum (("AccessOp", [ v1 ]))
  | AllocOp v1 -> let v1 = vof_allocOp v1 in Ocaml.VSum (("AllocOp", [ v1 ]))
  | UnaryTildeOp -> Ocaml.VSum (("UnaryTildeOp", []))
  | UnaryNotOp -> Ocaml.VSum (("UnaryNotOp", []))
  | CommaOp -> Ocaml.VSum (("CommaOp", []))
and vof_cast_operator =
  function
  | Static_cast -> Ocaml.VSum (("Static_cast", []))
  | Dynamic_cast -> Ocaml.VSum (("Dynamic_cast", []))
  | Const_cast -> Ocaml.VSum (("Const_cast", []))
  | Reinterpret_cast -> Ocaml.VSum (("Reinterpret_cast", []))
and vof_constExpression v = vof_expression v
and vof_statement v = vof_wrap vof_statementbis v
and vof_statementbis =
  function
  | Compound v1 ->
      let v1 = vof_compound v1 in Ocaml.VSum (("Compound", [ v1 ]))
  | ExprStatement v1 ->
      let v1 = vof_exprStatement v1 in Ocaml.VSum (("ExprStatement", [ v1 ]))
  | Labeled v1 -> let v1 = vof_labeled v1 in Ocaml.VSum (("Labeled", [ v1 ]))
  | Selection v1 ->
      let v1 = vof_selection v1 in Ocaml.VSum (("Selection", [ v1 ]))
  | Iteration v1 ->
      let v1 = vof_iteration v1 in Ocaml.VSum (("Iteration", [ v1 ]))
  | Jump v1 -> let v1 = vof_jump v1 in Ocaml.VSum (("Jump", [ v1 ]))
  | DeclStmt v1 ->
      let v1 = vof_block_declaration v1 in Ocaml.VSum (("DeclStmt", [ v1 ]))
  | Try ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_compound v2
      and v3 = Ocaml.vof_list vof_handler v3
      in Ocaml.VSum (("Try", [ v1; v2; v3 ]))
  | NestedFunc v1 ->
      let v1 = vof_func_definition v1 in Ocaml.VSum (("NestedFunc", [ v1 ]))
  | MacroStmt -> Ocaml.VSum (("MacroStmt", []))
  | StmtTodo -> Ocaml.VSum (("StmtTodo", []))
and vof_compound v = vof_brace (Ocaml.vof_list vof_statement_sequencable) v
and vof_statement_sequencable =
  function
  | StmtElem v1 ->
      let v1 = vof_statement v1 in Ocaml.VSum (("StmtElem", [ v1 ]))
  | CppDirectiveStmt v1 ->
      let v1 = vof_cpp_directive v1
      in Ocaml.VSum (("CppDirectiveStmt", [ v1 ]))
  | IfdefStmt v1 ->
      let v1 = vof_ifdef_directive v1 in Ocaml.VSum (("IfdefStmt", [ v1 ]))
and vof_exprStatement v = Ocaml.vof_option vof_expression v
and vof_labeled =
  function
  | Label ((v1, v2)) ->
      let v1 = Ocaml.vof_string v1
      and v2 = vof_statement v2
      in Ocaml.VSum (("Label", [ v1; v2 ]))
  | Case ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_statement v2
      in Ocaml.VSum (("Case", [ v1; v2 ]))
  | CaseRange ((v1, v2, v3)) ->
      let v1 = vof_expression v1
      and v2 = vof_expression v2
      and v3 = vof_statement v3
      in Ocaml.VSum (("CaseRange", [ v1; v2; v3 ]))
  | Default v1 ->
      let v1 = vof_statement v1 in Ocaml.VSum (("Default", [ v1 ]))
and vof_selection =
  function
  | If ((v1, v2, v3, v4, v5)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren vof_expression v2
      and v3 = vof_statement v3
      and v4 = Ocaml.vof_option vof_tok v4
      and v5 = vof_statement v5
      in Ocaml.VSum (("If", [ v1; v2; v3; v4; v5 ]))
  | Switch ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren vof_expression v2
      and v3 = vof_statement v3
      in Ocaml.VSum (("Switch", [ v1; v2; v3 ]))
and vof_iteration =
  function
  | While ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren vof_expression v2
      and v3 = vof_statement v3
      in Ocaml.VSum (("While", [ v1; v2; v3 ]))
  | DoWhile ((v1, v2, v3, v4, v5)) ->
      let v1 = vof_tok v1
      and v2 = vof_statement v2
      and v3 = vof_tok v3
      and v4 = vof_paren vof_expression v4
      and v5 = vof_tok v5
      in Ocaml.VSum (("DoWhile", [ v1; v2; v3; v4; v5 ]))
  | For ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 =
        vof_paren
          (fun (v1, v2, v3) ->
             let v1 = vof_wrap vof_exprStatement v1
             and v2 = vof_wrap vof_exprStatement v2
             and v3 = vof_wrap vof_exprStatement v3
             in Ocaml.VTuple [ v1; v2; v3 ])
          v2
      and v3 = vof_statement v3
      in Ocaml.VSum (("For", [ v1; v2; v3 ]))
  | MacroIteration ((v1, v2, v3)) ->
      let v1 = vof_wrap2 Ocaml.vof_string v1
      and v2 = vof_paren (vof_comma_list vof_argument) v2
      and v3 = vof_statement v3
      in Ocaml.VSum (("MacroIteration", [ v1; v2; v3 ]))
and vof_jump =
  function
  | Goto v1 -> let v1 = Ocaml.vof_string v1 in Ocaml.VSum (("Goto", [ v1 ]))
  | Continue -> Ocaml.VSum (("Continue", []))
  | Break -> Ocaml.VSum (("Break", []))
  | Return -> Ocaml.VSum (("Return", []))
  | ReturnExpr v1 ->
      let v1 = vof_expression v1 in Ocaml.VSum (("ReturnExpr", [ v1 ]))
  | GotoComputed v1 ->
      let v1 = vof_expression v1 in Ocaml.VSum (("GotoComputed", [ v1 ]))
and vof_handler (v1, v2, v3) =
  let v1 = vof_tok v1
  and v2 = vof_paren vof_exception_declaration v2
  and v3 = vof_compound v3
  in Ocaml.VTuple [ v1; v2; v3 ]
and vof_exception_declaration =
  function
  | ExnDeclEllipsis v1 ->
      let v1 = vof_tok v1 in Ocaml.VSum (("ExnDeclEllipsis", [ v1 ]))
  | ExnDecl v1 ->
      let v1 = vof_parameter v1 in Ocaml.VSum (("ExnDecl", [ v1 ]))
and vof_block_declaration =
  function
  | DeclList ((v1, v2)) ->
      let v1 = vof_comma_list vof_onedecl v1
      and v2 = vof_tok v2
      in Ocaml.VSum (("DeclList", [ v1; v2 ]))
  | MacroDecl ((v1, v2, v3, v4)) ->
      let v1 = Ocaml.vof_list vof_tok v1
      and v2 = vof_wrap2 Ocaml.vof_string v2
      and v3 = vof_paren (vof_comma_list vof_argument) v3
      and v4 = vof_tok v4
      in Ocaml.VSum (("MacroDecl", [ v1; v2; v3; v4 ]))
  | UsingDecl v1 ->
      let v1 =
        (match v1 with
         | (v1, v2, v3) ->
             let v1 = vof_tok v1
             and v2 = vof_name v2
             and v3 = vof_tok v3
             in Ocaml.VTuple [ v1; v2; v3 ])
      in Ocaml.VSum (("UsingDecl", [ v1 ]))
  | UsingDirective ((v1, v2, v3, v4)) ->
      let v1 = vof_tok v1
      and v2 = vof_tok v2
      and v3 = vof_namespace_name v3
      and v4 = vof_tok v4
      in Ocaml.VSum (("UsingDirective", [ v1; v2; v3; v4 ]))
  | NameSpaceAlias ((v1, v2, v3, v4, v5)) ->
      let v1 = vof_tok v1
      and v2 = vof_wrap2 Ocaml.vof_string v2
      and v3 = vof_tok v3
      and v4 = vof_namespace_name v4
      and v5 = vof_tok v5
      in Ocaml.VSum (("NameSpaceAlias", [ v1; v2; v3; v4; v5 ]))
  | Asm ((v1, v2, v3, v4)) ->
      let v1 = vof_tok v1
      and v2 = Ocaml.vof_option vof_tok v2
      and v3 = vof_paren vof_asmbody v3
      and v4 = vof_tok v4
      in Ocaml.VSum (("Asm", [ v1; v2; v3; v4 ]))
and
  vof_onedecl {
                v_namei = v_v_namei;
                v_type = v_v_type;
                v_storage = v_v_storage
              } =
  let bnds = [] in
  let arg = vof_storage v_v_storage in
  let bnd = ("v_storage", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_fullType v_v_type in
  let bnd = ("v_type", arg) in
  let bnds = bnd :: bnds in
  let arg =
    Ocaml.vof_option
      (fun (v1, v2) ->
         let v1 = vof_name v1
         and v2 = Ocaml.vof_option vof_init v2
         in Ocaml.VTuple [ v1; v2 ])
      v_v_namei in
  let bnd = ("v_namei", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_storage v = vof_storagebis v
and vof_storagebis =
  function
  | NoSto -> Ocaml.VSum (("NoSto", []))
  | StoTypedef v1 -> 
    let v1 = vof_tok v1 in
    Ocaml.VSum (("StoTypedef", [v1]))
  | Sto v1 -> let v1 = vof_wrap2 vof_storageClass v1 in Ocaml.VSum (("Sto", [ v1 ]))
and vof_storageClass =
  function
  | Auto -> Ocaml.VSum (("Auto", []))
  | Static -> Ocaml.VSum (("Static", []))
  | Register -> Ocaml.VSum (("Register", []))
  | Extern -> Ocaml.VSum (("Extern", []))
and vof_init =
  function
  | EqInit ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_initialiser v2
      in Ocaml.VSum (("EqInit", [ v1; v2 ]))
  | ObjInit v1 ->
      let v1 = vof_paren (vof_comma_list vof_argument) v1
      in Ocaml.VSum (("ObjInit", [ v1 ]))
and vof_initialiser =
  function
  | InitExpr v1 ->
      let v1 = vof_expression v1 in Ocaml.VSum (("InitExpr", [ v1 ]))
  | InitList v1 ->
      let v1 = vof_brace (vof_comma_list vof_initialiser) v1
      in Ocaml.VSum (("InitList", [ v1 ]))
  | InitDesignators ((v1, v2, v3)) ->
      let v1 = Ocaml.vof_list vof_designator v1
      and v2 = vof_tok v2
      and v3 = vof_initialiser v3
      in Ocaml.VSum (("InitDesignators", [ v1; v2; v3 ]))
  | InitFieldOld ((v1, v2, v3)) ->
      let v1 = vof_wrap2 Ocaml.vof_string v1
      and v2 = vof_tok v2
      and v3 = vof_initialiser v3
      in Ocaml.VSum (("InitFieldOld", [ v1; v2; v3 ]))
  | InitIndexOld ((v1, v2)) ->
      let v1 = vof_bracket vof_expression v1
      and v2 = vof_initialiser v2
      in Ocaml.VSum (("InitIndexOld", [ v1; v2 ]))
and vof_designator =
  function
  | DesignatorField ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_wrap2 Ocaml.vof_string v2
      in Ocaml.VSum (("DesignatorField", [ v1; v2 ]))
  | DesignatorIndex v1 ->
      let v1 = vof_bracket vof_expression v1
      in Ocaml.VSum (("DesignatorIndex", [ v1 ]))
  | DesignatorRange v1 ->
      let v1 =
        vof_bracket
          (fun (v1, v2, v3) ->
             let v1 = vof_expression v1
             and v2 = vof_tok v2
             and v3 = vof_expression v3
             in Ocaml.VTuple [ v1; v2; v3 ])
          v1
      in Ocaml.VSum (("DesignatorRange", [ v1 ]))
and vof_asmbody (v1, v2) =
  let v1 = Ocaml.vof_list vof_tok v1
  and v2 = Ocaml.vof_list (vof_wrap vof_colon) v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_colon =
  function
  | Colon v1 ->
      let v1 = vof_comma_list vof_colon_option v1
      in Ocaml.VSum (("Colon", [ v1 ]))
and vof_colon_option v = vof_wrap vof_colon_optionbis v
and vof_colon_optionbis =
  function
  | ColonMisc -> Ocaml.VSum (("ColonMisc", []))
  | ColonExpr v1 ->
      let v1 = vof_paren vof_expression v1
      in Ocaml.VSum (("ColonExpr", [ v1 ]))
and
  vof_func_definition {
                        f_name = v_f_name;
                        f_type = v_f_type;
                        f_storage = v_f_storage;
                        f_body = v_f_body
                      } =
  let bnds = [] in
  let arg = vof_compound v_f_body in
  let bnd = ("f_body", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_storage v_f_storage in
  let bnd = ("f_storage", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_functionType v_f_type in
  let bnd = ("f_type", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_name v_f_name in
  let bnd = ("f_name", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and
  vof_functionType {
                     ft_ret = v_ft_ret;
                     ft_params = v_ft_params;
                     ft_dots = v_ft_dots;
                     ft_const = v_ft_const;
                     ft_throw = v_ft_throw
                   } =
  let bnds = [] in
  let arg = Ocaml.vof_option vof_exn_spec v_ft_throw in
  let bnd = ("ft_throw", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_option vof_tok v_ft_const in
  let bnd = ("ft_const", arg) in
  let bnds = bnd :: bnds in
  let arg =
    Ocaml.vof_option
      (fun (v1, v2) ->
         let v1 = vof_tok v1 and v2 = vof_tok v2 in Ocaml.VTuple [ v1; v2 ])
      v_ft_dots in
  let bnd = ("ft_dots", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_paren (vof_comma_list vof_parameter) v_ft_params in
  let bnd = ("ft_params", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_fullType v_ft_ret in
  let bnd = ("ft_ret", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and
  vof_parameter {
                  p_name = v_p_name;
                  p_type = v_p_type;
                  p_register = v_p_register;
                  p_val = v_p_val
                } =
  let bnds = [] in
  let arg =
    Ocaml.vof_option
      (fun (v1, v2) ->
         let v1 = vof_tok v1
         and v2 = vof_expression v2
         in Ocaml.VTuple [ v1; v2 ])
      v_p_val in
  let bnd = ("p_val", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_option vof_tok v_p_register in
  let bnd = ("p_register", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_fullType v_p_type in
  let bnd = ("p_type", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_option (vof_wrap2 Ocaml.vof_string) v_p_name in
  let bnd = ("p_name", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_func_or_else =
  function
  | FunctionOrMethod v1 ->
      let v1 = vof_func_definition v1
      in Ocaml.VSum (("FunctionOrMethod", [ v1 ]))
  | Constructor ((v1)) ->
      let v1 = vof_func_definition v1
      in Ocaml.VSum (("Constructor", [ v1 ]))
  | Destructor v1 ->
      let v1 = vof_func_definition v1 in Ocaml.VSum (("Destructor", [ v1 ]))
and vof_exn_spec (v1, v2) =
  let v1 = vof_tok v1
  and v2 = vof_paren (vof_comma_list2 vof_name) v2
  in Ocaml.VTuple [ v1; v2 ]

and
  vof_class_definition {
                         c_kind = v_c_kind;
                         c_name = v_c_name;
                         c_inherit = v_c_inherit;
                         c_members = v_c_members
                       } =
  let bnds = [] in
  let arg =
    vof_brace (Ocaml.vof_list vof_class_member_sequencable) v_c_members in
  let bnd = ("c_members", arg) in
  let bnds = bnd :: bnds in
  let arg =
    Ocaml.vof_option
      (fun (v1, v2) ->
         let v1 = vof_tok v1
         and v2 = vof_comma_list vof_base_clause v2
         in Ocaml.VTuple [ v1; v2 ])
      v_c_inherit in
  let bnd = ("c_inherit", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_option vof_ident_name v_c_name in
  let bnd = ("c_name", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_wrap2 vof_structUnion v_c_kind in
  let bnd = ("c_kind", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_structUnion =
  function
  | Struct -> Ocaml.VSum (("Struct", []))
  | Union -> Ocaml.VSum (("Union", []))
  | Class -> Ocaml.VSum (("Class", []))
and
  vof_base_clause {
                    i_name = v_i_name;
                    i_virtual = v_i_virtual;
                    i_access = v_i_access
                  } =
  let bnds = [] in
  let arg = Ocaml.vof_option (vof_wrap2 vof_access_spec) v_i_access in
  let bnd = ("i_access", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_option vof_tok v_i_virtual in
  let bnd = ("i_virtual", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_class_name v_i_name in
  let bnd = ("i_name", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_access_spec =
  function
  | Public -> Ocaml.VSum (("Public", []))
  | Private -> Ocaml.VSum (("Private", []))
  | Protected -> Ocaml.VSum (("Protected", []))

and vof_method_decl = function
  | ConstructorDecl ((v1, v2, v3)) ->
      let v1 = vof_wrap2 Ocaml.vof_string v1
      and v2 = vof_paren (vof_comma_list vof_parameter) v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("ConstructorDecl", [ v1; v2; v3 ]))
  | DestructorDecl ((v1, v2, v3, v4, v5)) ->
      let v1 = vof_tok v1
      and v2 = vof_wrap2 Ocaml.vof_string v2
      and v3 = vof_paren (Ocaml.vof_option vof_tok) v3
      and v4 = Ocaml.vof_option vof_exn_spec v4
      and v5 = vof_tok v5
      in Ocaml.VSum (("DestructorDecl", [ v1; v2; v3; v4; v5 ]))
  | MethodDecl ((v1, v2, v3)) ->
      let v1 = vof_onedecl v1
      and v2 =
        Ocaml.vof_option
          (fun (v1, v2) ->
             let v1 = vof_tok v1
             and v2 = vof_tok v2
             in Ocaml.VTuple [ v1; v2 ])
          v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("MethodDecl", [ v1; v2; v3 ]))

and vof_class_member =
  function
  | Access ((v1, v2)) ->
      let v1 = vof_wrap2 vof_access_spec v1
      and v2 = vof_tok v2
      in Ocaml.VSum (("Access", [ v1; v2 ]))
  | MemberField (v1, v2) ->
      let v1 = (vof_comma_list vof_fieldkind) v1
      and v2 = vof_tok v2
      in Ocaml.VSum (("MemberField", [ v1; v2 ]))
  | MemberFunc v1 ->
      let v1 = vof_func_or_else v1 in Ocaml.VSum (("MemberFunc", [ v1 ]))
  | MemberDecl v1 ->
      let v1 = vof_method_decl v1 in 
      Ocaml.VSum (("MemberDecl", [ v1 ]))
  | QualifiedIdInClass ((v1, v2)) ->
      let v1 = vof_name v1
      and v2 = vof_tok v2
      in Ocaml.VSum (("QualifiedIdInClass", [ v1; v2 ]))
  | TemplateDeclInClass v1 ->
      let v1 =
        (match v1 with
         | (v1, v2, v3) ->
             let v1 = vof_tok v1
             and v2 = vof_template_parameters v2
             and v3 = vof_declaration v3
             in Ocaml.VTuple [ v1; v2; v3 ])
      in Ocaml.VSum (("TemplateDeclInClass", [ v1 ]))
  | UsingDeclInClass v1 ->
      let v1 =
        (match v1 with
         | (v1, v2, v3) ->
             let v1 = vof_tok v1
             and v2 = vof_name v2
             and v3 = vof_tok v3
             in Ocaml.VTuple [ v1; v2; v3 ])
      in Ocaml.VSum (("UsingDeclInClass", [ v1 ]))
  | EmptyField v1 ->
      let v1 = vof_tok v1 in Ocaml.VSum (("EmptyField", [ v1 ]))
and vof_fieldkind =
  function
  | FieldDecl v1 ->
      let v1 = vof_onedecl v1 in Ocaml.VSum (("FieldDecl", [ v1 ]))
  | BitField ((v1, v2, v3, v4)) ->
      let v1 = Ocaml.vof_option (vof_wrap2 Ocaml.vof_string) v1
      and v2 = vof_tok v2
      and v3 = vof_fullType v3
      and v4 = vof_constExpression v4
      in Ocaml.VSum (("BitField", [ v1; v2; v3; v4 ]))
and vof_class_member_sequencable =
  function
  | ClassElem v1 ->
      let v1 = vof_class_member v1 in Ocaml.VSum (("ClassElem", [ v1 ]))
  | CppDirectiveStruct v1 ->
      let v1 = vof_cpp_directive v1
      in Ocaml.VSum (("CppDirectiveStruct", [ v1 ]))
  | IfdefStruct v1 ->
      let v1 = vof_ifdef_directive v1 in Ocaml.VSum (("IfdefStruct", [ v1 ]))
and vof_cpp_directive =
  function
  | Define ((v1, v2, v3, v4)) ->
      let v1 = vof_tok v1
      and v2 = vof_wrap2 Ocaml.vof_string v2
      and v3 = vof_define_kind v3
      and v4 = vof_define_val v4
      in Ocaml.VSum (("Define", [ v1; v2; v3; v4 ]))
  | Include ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_inc_kind v2
      and v3 = Ocaml.vof_string v3
      in Ocaml.VSum (("Include", [ v1; v2; v3 ]))
  | Undef v1 ->
      let v1 = vof_wrap2 Ocaml.vof_string v1
      in Ocaml.VSum (("Undef", [ v1 ]))
  | PragmaAndCo v1 ->
      let v1 = vof_tok v1 in Ocaml.VSum (("PragmaAndCo", [ v1 ]))
and vof_define_kind =
  function
  | DefineVar -> Ocaml.VSum (("DefineVar", []))
  | DefineFunc v1 ->
      let v1 = vof_paren (vof_comma_list (vof_wrap Ocaml.vof_string)) v1
      in Ocaml.VSum (("DefineFunc", [ v1 ]))
and vof_define_val =
  function
  | DefinePrintWrapper ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren vof_expression v2
      and v3 = vof_name v3
      in Ocaml.VSum (("DefinePrintWrapper", [ v1; v2; v3 ]))
  | DefineExpr v1 ->
      let v1 = vof_expression v1 in Ocaml.VSum (("DefineExpr", [ v1 ]))
  | DefineStmt v1 ->
      let v1 = vof_statement v1 in Ocaml.VSum (("DefineStmt", [ v1 ]))
  | DefineType v1 ->
      let v1 = vof_fullType v1 in Ocaml.VSum (("DefineType", [ v1 ]))
  | DefineDoWhileZero v1 ->
      let v1 = vof_wrap vof_statement v1
      in Ocaml.VSum (("DefineDoWhileZero", [ v1 ]))
  | DefineFunction v1 ->
      let v1 = vof_func_definition v1
      in Ocaml.VSum (("DefineFunction", [ v1 ]))
  | DefineInit v1 ->
      let v1 = vof_initialiser v1 in Ocaml.VSum (("DefineInit", [ v1 ]))
  | DefineText v1 ->
      let v1 = vof_wrap Ocaml.vof_string v1
      in Ocaml.VSum (("DefineText", [ v1 ]))
  | DefineEmpty -> Ocaml.VSum (("DefineEmpty", []))
  | DefineTodo -> Ocaml.VSum (("DefineTodo", []))
and vof_inc_kind =
  function
  | Local -> Ocaml.VSum (("Local", [ ]))
  | Standard -> Ocaml.VSum (("Standard", [ ]))
  | Weird -> Ocaml.VSum (("Weird", [ ]))

and vof_ifdef_directive v = vof_wrap2 vof_ifdefkind v
and vof_ifdefkind =
  function
  | Ifdef -> Ocaml.VSum (("Ifdef", []))
  | IfdefElse -> Ocaml.VSum (("IfdefElse", []))
  | IfdefElseif -> Ocaml.VSum (("IfdefElseif", []))
  | IfdefEndif -> Ocaml.VSum (("IfdefEndif", []))

and vof_declaration =
  function
  | BlockDecl v1 ->
      let v1 = vof_block_declaration v1 in Ocaml.VSum (("BlockDecl", [ v1 ]))
  | Func v1 -> let v1 = vof_func_or_else v1 in Ocaml.VSum (("Func", [ v1 ]))
  | TemplateDecl (v1, v2, v3) ->
    let v1 = vof_tok v1
    and v2 = vof_template_parameters v2
    and v3 = vof_declaration v3
    in Ocaml.VSum (("TemplateDecl", [ v1; v2; v3 ]))
  | TemplateSpecialization ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_angle Ocaml.vof_unit v2
      and v3 = vof_declaration v3
      in Ocaml.VSum (("TemplateSpecialization", [ v1; v2; v3 ]))
  | ExternC ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_tok v2
      and v3 = vof_declaration v3
      in Ocaml.VSum (("ExternC", [ v1; v2; v3 ]))
  | ExternCList ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_tok v2
      and v3 = vof_brace (Ocaml.vof_list vof_declaration_sequencable) v3
      in Ocaml.VSum (("ExternCList", [ v1; v2; v3 ]))
  | NameSpace ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_wrap2 Ocaml.vof_string v2
      and v3 = vof_brace (Ocaml.vof_list vof_declaration_sequencable) v3
      in Ocaml.VSum (("NameSpace", [ v1; v2; v3 ]))
  | NameSpaceExtend ((v1, v2)) ->
      let v1 = Ocaml.vof_string v1
      and v2 = Ocaml.vof_list vof_declaration_sequencable v2
      in Ocaml.VSum (("NameSpaceExtend", [ v1; v2 ]))
  | NameSpaceAnon ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_brace (Ocaml.vof_list vof_declaration_sequencable) v2
      in Ocaml.VSum (("NameSpaceAnon", [ v1; v2 ]))
  | EmptyDef v1 -> let v1 = vof_tok v1 in Ocaml.VSum (("EmptyDef", [ v1 ]))
  | DeclTodo -> Ocaml.VSum (("DeclTodo", []))
and vof_template_parameter v = vof_parameter v
and vof_template_parameters v =
  vof_angle (vof_comma_list vof_template_parameter) v
and vof_declaration_sequencable =
  function
  | NotParsedCorrectly v1 ->
      let v1 = Ocaml.vof_list vof_tok v1
      in Ocaml.VSum (("NotParsedCorrectly", [ v1 ]))
  | DeclElem v1 ->
      let v1 = vof_declaration v1 in Ocaml.VSum (("DeclElem", [ v1 ]))
  | CppDirectiveDecl v1 ->
      let v1 = vof_cpp_directive v1
      in Ocaml.VSum (("CppDirectiveDecl", [ v1 ]))
  | IfdefDecl v1 ->
      let v1 = vof_ifdef_directive v1 in Ocaml.VSum (("IfdefDecl", [ v1 ]))
  | MacroTop ((v1, v2, v3)) ->
      let v1 = vof_wrap2 Ocaml.vof_string v1
      and v2 = vof_paren (vof_comma_list vof_argument) v2
      and v3 = Ocaml.vof_option vof_tok v3
      in Ocaml.VSum (("MacroTop", [ v1; v2; v3 ]))
  | MacroVarTop ((v1, v2)) ->
      let v1 = vof_wrap2 Ocaml.vof_string v1
      and v2 = vof_tok v2
      in Ocaml.VSum (("MacroVarTop", [ v1; v2 ]))

and vof_toplevel v = vof_declaration_sequencable v
and vof_program v = Ocaml.vof_list vof_toplevel v
and vof_any =
  function
  | Program v1 -> let v1 = vof_program v1 in Ocaml.VSum (("Program", [ v1 ]))
  | Toplevel v1 ->
      let v1 = vof_toplevel v1 in Ocaml.VSum (("Toplevel", [ v1 ]))
  | BlockDecl2 v1 ->
      let v1 = vof_block_declaration v1
      in Ocaml.VSum (("BlockDecl2", [ v1 ]))
  | Stmt v1 -> let v1 = vof_statement v1 in Ocaml.VSum (("Stmt", [ v1 ]))
  | Expr v1 -> let v1 = vof_expression v1 in Ocaml.VSum (("Expr", [ v1 ]))
  | Init v1 -> let v1 = vof_initialiser v1 in Ocaml.VSum (("Init", [ v1 ]))
  | Type v1 -> let v1 = vof_fullType v1 in Ocaml.VSum (("Type", [ v1 ]))
  | Name v1 -> let v1 = vof_name v1 in Ocaml.VSum (("Name", [ v1 ]))
  | Cpp v1 -> let v1 = vof_cpp_directive v1 in Ocaml.VSum (("Cpp", [ v1 ]))
  | ClassDef v1 ->
      let v1 = vof_class_definition v1 in Ocaml.VSum (("ClassDef", [ v1 ]))
  | FuncDef v1 ->
      let v1 = vof_func_definition v1 in Ocaml.VSum (("FuncDef", [ v1 ]))
  | FuncOrElse v1 ->
      let v1 = vof_func_or_else v1 in Ocaml.VSum (("FuncOrElse", [ v1 ]))
  | Constant v1 ->
      let v1 = vof_constant v1 in Ocaml.VSum (("Constant", [ v1 ]))
  | Argument v1 ->
      let v1 = vof_argument v1 in Ocaml.VSum (("Argument", [ v1 ]))
  | Parameter v1 ->
      let v1 = vof_parameter v1 in Ocaml.VSum (("Parameter", [ v1 ]))
  | Body v1 -> let v1 = vof_compound v1 in Ocaml.VSum (("Body", [ v1 ]))
  | Info v1 -> let v1 = vof_info v1 in Ocaml.VSum (("Info", [ v1 ]))
  | InfoList v1 ->
      let v1 = Ocaml.vof_list vof_info v1
      in Ocaml.VSum (("InfoList", [ v1 ]))
  | ClassMember v1 ->
      let v1 = vof_class_member v1 in
      Ocaml.VSum (("ClassMember", [v1]))
  | OneDecl v1 ->
      let v1 = vof_onedecl v1 in
      Ocaml.VSum (("OneDecl", [v1]))
  
  
(* end auto generation *)

let vof_program ?(precision=M.default_precision) x = 
  Common.save_excursion _current_precision precision (fun () ->
    vof_program x
  )

let vof_any ?(precision=M.default_precision) x = 
  Common.save_excursion _current_precision precision (fun () ->
    vof_any x
  )

