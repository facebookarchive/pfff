(* generated by ocamltarzan: ocamltarzan -vof ast_php.ml *)

open Common

open Ast_php

let vof_string = Ocaml.vof_string
let vof_list = Ocaml.vof_list
let vof_option = Ocaml.vof_option
let vof_ref = Ocaml.vof_ref

(* pad: generated code starts here *)


let rec vof_info x = Parse_info.vof_info x
and vof_tok v = vof_info v
and vof_wrap _of_a (v1, v2) =
  let v1 = _of_a v1 and v2 = vof_info v2 in Ocaml.VTuple [ v1; v2 ]
and vof_paren _of_a (v1, v2, v3) =
  let v1 = vof_tok v1
  and v2 = _of_a v2
  and v3 = vof_tok v3
  in Ocaml.VTuple [ v1; v2; v3 ]
and vof_brace _of_a (v1, v2, v3) =
  let v1 = vof_tok v1
  and v2 = _of_a v2
  and v3 = vof_tok v3
  in Ocaml.VTuple [ v1; v2; v3 ]
and vof_bracket _of_a (v1, v2, v3) =
  let v1 = vof_tok v1
  and v2 = _of_a v2
  and v3 = vof_tok v3
  in Ocaml.VTuple [ v1; v2; v3 ]
and vof_single_angle _of_a (v1, v2, v3) =
  let v1 = vof_tok v1 in
  let v2 = _of_a v2 in
  let v3 = vof_tok v3
  in Ocaml.VTuple [ v1; v2; v3 ]

and vof_angle _of_a (v1, v2, v3) =
  let v1 = vof_tok v1
  and v2 = _of_a v2
  and v3 = vof_tok v3
  in Ocaml.VTuple [ v1; v2; v3 ]

and vof_comma_list _of_a xs =
  Ocaml.vof_list (fun x -> Ocaml.vof_either _of_a vof_info x) xs

and vof_comma_list_dots _of_a xs =
  Ocaml.vof_list (fun x -> Ocaml.vof_either3 _of_a vof_info vof_info x) xs

let rec vof_ident =
  function
  | Name v1 ->
      let v1 = vof_wrap vof_string v1 in Ocaml.VSum (("Name", [ v1 ]))
  | XhpName v1 ->
      let v1 = vof_wrap vof_xhp_tag v1 in Ocaml.VSum (("XhpName", [ v1 ]))
and vof_qualified_ident v = Ocaml.vof_list vof_qualified_ident_element v
and vof_qualified_ident_element =
  function
  | QI v1 -> let v1 = vof_ident v1 in Ocaml.VSum (("QI", [ v1 ]))
  | QITok v1 -> let v1 = vof_tok v1 in Ocaml.VSum (("QITok", [ v1 ]))


and vof_xhp_tag v = Ocaml.vof_list Ocaml.vof_string v
and vof_dname =
  function
  | DName v1 ->
      let v1 = vof_wrap vof_string v1 in Ocaml.VSum (("DName", [ v1 ]))
and vof_name x = vof_class_name_or_selfparent x
and vof_class_name_or_selfparent =
  function
  | XName (v1) ->
      let v1 = vof_qualified_ident v1
      in Ocaml.VSum (("XName", [ v1 ]))
  | Self v1 -> let v1 = vof_tok v1 in Ocaml.VSum (("Self", [ v1 ]))
  | Parent v1 -> let v1 = vof_tok v1 in Ocaml.VSum (("Parent", [ v1 ]))
  | LateStatic v1 -> let v1 = vof_tok v1 in Ocaml.VSum (("LateStatic", [ v1 ]))
and vof_type_args v = vof_single_angle (vof_comma_list vof_hint_type) v
and (vof_fully_qualified_class_name: Ast_php.class_name -> Ocaml.v) = fun
 v -> vof_hint_type v

and (vof_type_params: Ast_php.type_params -> Ocaml.v) = fun v ->
  vof_single_angle (vof_comma_list vof_type_param) v
and (vof_type_param: Ast_php.type_param -> Ocaml.v) =
  function
  | TParam v1 -> let v1 = vof_ident v1 in Ocaml.VSum (("TParam", [ v1 ]))
  | TParamConstraint ((v1, v2, v3)) ->
      let v1 = vof_ident v1
      and v2 = vof_tok v2
      and v3 = vof_class_name v3
      in Ocaml.VSum (("TParamConstraint", [ v1; v2; v3 ]))
and vof_class_name x = vof_hint_type x

and vof_ptype =
  function
  | BoolTy -> Ocaml.VSum (("BoolTy", []))
  | IntTy -> Ocaml.VSum (("IntTy", []))
  | DoubleTy -> Ocaml.VSum (("DoubleTy", []))
  | StringTy -> Ocaml.VSum (("StringTy", []))
  | ArrayTy -> Ocaml.VSum (("ArrayTy", []))
  | ObjectTy -> Ocaml.VSum (("ObjectTy", []))

and vof_expr = function
  | Id v1 ->
    let v1 = vof_name v1 in
    Ocaml.VSum ("Id", [ v1 ])

  | IdVar ((v1, v2)) ->
      let v1 = vof_dname v1
      and v2 = vof_ref Scope_code.vof_scope v2
      in Ocaml.VSum (("IdVar", [ v1; v2 ]))
  | This v1 -> let v1 = vof_tok v1 in Ocaml.VSum (("This", [ v1 ]))


  | Call ((v1, v2)) ->
      let v1 = vof_expr v1
      and v2 = vof_paren (vof_comma_list vof_argument) v2
      in Ocaml.VSum (("Call", [ v1; v2 ]))
  | ObjGet ((v1, v2, v3)) ->
      let v1 = vof_expr v1
      and v2 = vof_tok v2
      and v3 = vof_expr v3
      in Ocaml.VSum (("ObjGet", [ v1; v2; v3 ]))
  | ClassGet ((v1, v2, v3)) ->
      let v1 = vof_class_name_reference v1
      and v2 = vof_tok v2
      and v3 = vof_expr v3
      in Ocaml.VSum (("ClassGet", [ v1; v2; v3 ]))
  | ArrayGet ((v1, v2)) ->
      let v1 = vof_expr v1
      and v2 = vof_bracket (Ocaml.vof_option vof_expr) v2
      in Ocaml.VSum (("ArrayGet", [ v1; v2 ]))
  | HashGet ((v1, v2)) ->
      let v1 = vof_expr v1
      and v2 = vof_brace vof_expr v2
      in Ocaml.VSum (("HashGet", [ v1; v2 ]))
  | BraceIdent v1 ->
      let v1 = vof_brace vof_expr v1 in Ocaml.VSum (("BraceIdent", [ v1 ]))
  | Deref ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_expr v2
      in Ocaml.VSum (("Deref", [ v1; v2 ]))

  | Sc v1 -> let v1 = vof_scalar v1 in Ocaml.VSum (("Sc", [ v1 ]))
  | Binary ((v1, v2, v3)) ->
      let v1 = vof_expr v1
      and v2 = vof_wrap vof_binaryOp v2
      and v3 = vof_expr v3
      in Ocaml.VSum (("Binary", [ v1; v2; v3 ]))
  | Unary ((v1, v2)) ->
      let v1 = vof_wrap vof_unaryOp v1
      and v2 = vof_expr v2
      in Ocaml.VSum (("Unary", [ v1; v2 ]))
  | Assign ((v1, v2, v3)) ->
      let v1 = vof_lvalue v1
      and v2 = vof_tok v2
      and v3 = vof_expr v3
      in Ocaml.VSum (("Assign", [ v1; v2; v3 ]))
  | AssignOp ((v1, v2, v3)) ->
      let v1 = vof_lvalue v1
      and v2 = vof_wrap vof_assignOp v2
      and v3 = vof_expr v3
      in Ocaml.VSum (("AssignOp", [ v1; v2; v3 ]))
  | Postfix ((v1, v2)) ->
      let v1 = vof_rw_variable v1
      and v2 = vof_wrap vof_fixOp v2
      in Ocaml.VSum (("Postfix", [ v1; v2 ]))
  | Infix ((v1, v2)) ->
      let v1 = vof_wrap vof_fixOp v1
      and v2 = vof_rw_variable v2
      in Ocaml.VSum (("Infix", [ v1; v2 ]))
  | CondExpr ((v1, v2, v3, v4, v5)) ->
      let v1 = vof_expr v1
      and v2 = vof_tok v2
      and v3 = vof_option vof_expr v3
      and v4 = vof_tok v4
      and v5 = vof_expr v5
      in Ocaml.VSum (("CondExpr", [ v1; v2; v3; v4; v5 ]))
  | AssignList ((v1, v2, v3, v4)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren (vof_comma_list vof_list_assign) v2
      and v3 = vof_tok v3
      and v4 = vof_expr v4
      in Ocaml.VSum (("AssignList", [ v1; v2; v3; v4 ]))
  | ArrayLong ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren (vof_comma_list vof_array_pair) v2
      in Ocaml.VSum (("ArrayLong", [ v1; v2 ]))
  | ArrayShort ((v1)) ->
      let v1 = vof_bracket (vof_comma_list vof_array_pair) v1
      in Ocaml.VSum (("ArrayShort", [ v1]))
  | Collection ((v1, v2)) ->
      let v1 = vof_name v1 in
      let v2 = vof_brace (vof_comma_list vof_array_pair) v2 in
      Ocaml.VSum (("Collection", [ v1; v2 ]))
  | New ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_class_name_reference v2
      and v3 = vof_option (vof_paren (vof_comma_list vof_argument)) v3
      in Ocaml.VSum (("New", [ v1; v2; v3 ]))
  | Clone ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_expr v2
      in Ocaml.VSum (("Clone", [ v1; v2 ]))
  | AssignRef ((v1, v2, v3, v4)) ->
      let v1 = vof_lvalue v1
      and v2 = vof_tok v2
      and v3 = vof_tok v3
      and v4 = vof_lvalue v4
      in Ocaml.VSum (("AssignRef", [ v1; v2; v3; v4 ]))
  | AssignNew ((v1, v2, v3, v4, v5, v6)) ->
      let v1 = vof_lvalue v1
      and v2 = vof_tok v2
      and v3 = vof_tok v3
      and v4 = vof_tok v4
      and v5 = vof_class_name_reference v5
      and v6 = vof_option (vof_paren (vof_comma_list vof_argument)) v6
      in Ocaml.VSum (("AssignNew", [ v1; v2; v3; v4; v5; v6 ]))
  | Cast ((v1, v2)) ->
      let v1 = vof_wrap vof_castOp v1
      and v2 = vof_expr v2
      in Ocaml.VSum (("Cast", [ v1; v2 ]))
  | CastUnset ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_expr v2
      in Ocaml.VSum (("CastUnset", [ v1; v2 ]))
  | InstanceOf ((v1, v2, v3)) ->
      let v1 = vof_expr v1
      and v2 = vof_tok v2
      and v3 = vof_class_name_reference v3
      in Ocaml.VSum (("InstanceOf", [ v1; v2; v3 ]))
  | Eval ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren vof_expr v2
      in Ocaml.VSum (("Eval", [ v1; v2 ]))
  | Lambda v1 ->
      let v1 = vof_lambda_def v1 in Ocaml.VSum (("Lambda", [ v1 ]))
  | ShortLambda v1 ->
      let v1 = vof_short_lambda_def v1
      in Ocaml.VSum (("ShortLambda", [ v1 ]))
  | Exit ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_option (vof_paren (vof_option vof_expr)) v2
      in Ocaml.VSum (("Exit", [ v1; v2 ]))
  | At ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_expr v2
      in Ocaml.VSum (("At", [ v1; v2 ]))
  | Print ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_expr v2
      in Ocaml.VSum (("Print", [ v1; v2 ]))
  | BackQuote ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_list vof_encaps v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("BackQuote", [ v1; v2; v3 ]))
  | Include ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_expr v2
      in Ocaml.VSum (("Include", [ v1; v2 ]))
  | IncludeOnce ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_expr v2
      in Ocaml.VSum (("IncludeOnce", [ v1; v2 ]))
  | Require ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_expr v2
      in Ocaml.VSum (("Require", [ v1; v2 ]))
  | RequireOnce ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_expr v2
      in Ocaml.VSum (("RequireOnce", [ v1; v2 ]))
  | Yield ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_array_pair v2
      in Ocaml.VSum (("Yield", [ v1; v2 ]))
  | YieldBreak ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_tok v2
      in Ocaml.VSum (("YieldBreak", [ v1; v2 ]))
  | Await ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_expr v2
      in Ocaml.VSum (("Await", [ v1; v2 ]))
  | Empty ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren vof_lvalue v2
      in Ocaml.VSum (("Empty", [ v1; v2 ]))
  | Isset ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren (vof_comma_list vof_lvalue) v2
      in Ocaml.VSum (("Isset", [ v1; v2 ]))
  | XhpHtml v1 ->
      let v1 = vof_xhp_html v1 in Ocaml.VSum (("XhpHtml", [ v1 ]))
  | SgrepExprDots v1 ->
      let v1 = vof_info v1 in Ocaml.VSum (("SgrepExprDots", [ v1 ]))
  | ParenExpr v1 ->
      let v1 = vof_paren vof_expr v1 in Ocaml.VSum (("ParenExpr", [ v1 ]))
and vof_scalar =
  function
  | C v1 ->
      let v1 = vof_constant v1 in Ocaml.VSum (("C", [ v1 ]))
  | Guil ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_list vof_encaps v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("Guil", [ v1; v2; v3 ]))
  | HereDoc ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_list vof_encaps v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("HereDoc", [ v1; v2; v3 ]))
and vof_constant =
  function
  | Int v1 -> let v1 = vof_wrap vof_string v1 in Ocaml.VSum (("Int", [ v1 ]))
  | Double v1 ->
      let v1 = vof_wrap vof_string v1 in Ocaml.VSum (("Double", [ v1 ]))
  | String v1 ->
      let v1 = vof_wrap vof_string v1 in Ocaml.VSum (("String", [ v1 ]))
  | PreProcess v1 ->
      let v1 = vof_wrap vof_cpp_directive v1
      in Ocaml.VSum (("PreProcess", [ v1 ]))
  | XdebugClass ((v1, v2)) ->
      let v1 = vof_name v1
      and v2 = Ocaml.vof_list vof_class_stmt v2
      in Ocaml.VSum (("XdebugClass", [ v1; v2 ]))
  | XdebugResource -> Ocaml.VSum (("XdebugResource", []))
and vof_cpp_directive =
  function
  | Line -> Ocaml.VSum (("Line", []))
  | File -> Ocaml.VSum (("File", []))
  | Dir -> Ocaml.VSum (("Dir", []))
  | ClassC -> Ocaml.VSum (("ClassC", []))
  | MethodC -> Ocaml.VSum (("MethodC", []))
  | FunctionC -> Ocaml.VSum (("FunctionC", []))
  | TraitC -> Ocaml.VSum (("TraitC", []))
  | NamespaceC -> Ocaml.VSum (("NamespaceC", []))
and vof_encaps =
  function
  | EncapsString v1 ->
      let v1 = vof_wrap vof_string v1
      in Ocaml.VSum (("EncapsString", [ v1 ]))
  | EncapsVar v1 ->
      let v1 = vof_lvalue v1 in Ocaml.VSum (("EncapsVar", [ v1 ]))
  | EncapsCurly ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_lvalue v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("EncapsCurly", [ v1; v2; v3 ]))
  | EncapsDollarCurly ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_lvalue v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("EncapsDollarCurly", [ v1; v2; v3 ]))
  | EncapsExpr ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_expr v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("EncapsExpr", [ v1; v2; v3 ]))
and vof_fixOp =
  function
  | Dec -> Ocaml.VSum (("Dec", []))
  | Inc -> Ocaml.VSum (("Inc", []))
and vof_binaryOp =
  function
  | Arith v1 -> let v1 = vof_arithOp v1 in Ocaml.VSum (("Arith", [ v1 ]))
  | Logical v1 ->
      let v1 = vof_logicalOp v1 in Ocaml.VSum (("Logical", [ v1 ]))
  | BinaryConcat -> Ocaml.VSum (("BinaryConcat", []))
  | Pipe -> Ocaml.VSum (("Pipe", []))
  | CombinedComparison -> Ocaml.VSum(("CombinedComparison", []))
and vof_arithOp =
  function
  | Plus -> Ocaml.VSum (("Plus", []))
  | Minus -> Ocaml.VSum (("Minus", []))
  | Mul -> Ocaml.VSum (("Mul", []))
  | Div -> Ocaml.VSum (("Div", []))
  | Mod -> Ocaml.VSum (("Mod", []))
  | DecLeft -> Ocaml.VSum (("DecLeft", []))
  | DecRight -> Ocaml.VSum (("DecRight", []))
  | And -> Ocaml.VSum (("And", []))
  | Or -> Ocaml.VSum (("Or", []))
  | Xor -> Ocaml.VSum (("Xor", []))
and vof_logicalOp =
  function
  | Inf -> Ocaml.VSum (("Inf", []))
  | Sup -> Ocaml.VSum (("Sup", []))
  | InfEq -> Ocaml.VSum (("InfEq", []))
  | SupEq -> Ocaml.VSum (("SupEq", []))
  | Eq -> Ocaml.VSum (("Eq", []))
  | NotEq -> Ocaml.VSum (("NotEq", []))
  | Identical -> Ocaml.VSum (("Identical", []))
  | NotIdentical -> Ocaml.VSum (("NotIdentical", []))
  | AndLog -> Ocaml.VSum (("AndLog", []))
  | OrLog -> Ocaml.VSum (("OrLog", []))
  | XorLog -> Ocaml.VSum (("XorLog", []))
  | AndBool -> Ocaml.VSum (("AndBool", []))
  | OrBool -> Ocaml.VSum (("OrBool", []))
and vof_assignOp =
  function
  | AssignOpArith v1 ->
      let v1 = vof_arithOp v1 in Ocaml.VSum (("AssignOpArith", [ v1 ]))
  | AssignConcat -> Ocaml.VSum (("AssignConcat", []))
and vof_unaryOp =
  function
  | UnPlus -> Ocaml.VSum (("UnPlus", []))
  | UnMinus -> Ocaml.VSum (("UnMinus", []))
  | UnBang -> Ocaml.VSum (("UnBang", []))
  | UnTilde -> Ocaml.VSum (("UnTilde", []))
and vof_castOp v = vof_ptype v
and vof_list_assign =
  function
  | ListVar v1 ->
      let v1 = vof_lvalue v1 in Ocaml.VSum (("ListVar", [ v1 ]))
  | ListList ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren (vof_comma_list vof_list_assign) v2
      in Ocaml.VSum (("ListList", [ v1; v2 ]))
  | ListEmpty -> Ocaml.VSum (("ListEmpty", []))
and vof_array_pair =
  function
  | ArrayExpr v1 ->
      let v1 = vof_expr v1 in Ocaml.VSum (("ArrayExpr", [ v1 ]))
  | ArrayRef ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_lvalue v2
      in Ocaml.VSum (("ArrayRef", [ v1; v2 ]))
  | ArrayArrowExpr ((v1, v2, v3)) ->
      let v1 = vof_expr v1
      and v2 = vof_tok v2
      and v3 = vof_expr v3
      in Ocaml.VSum (("ArrayArrowExpr", [ v1; v2; v3 ]))
  | ArrayArrowRef ((v1, v2, v3, v4)) ->
      let v1 = vof_expr v1
      and v2 = vof_tok v2
      and v3 = vof_tok v3
      and v4 = vof_lvalue v4
      in Ocaml.VSum (("ArrayArrowRef", [ v1; v2; v3; v4 ]))
and vof_class_name_reference a = vof_expr a

and vof_xhp_html =
  function
  | Xhp ((v1, v2, v3, v4, v5)) ->
      let v1 = vof_wrap vof_xhp_tag v1
      and v2 = Ocaml.vof_list vof_xhp_attribute v2
      and v3 = vof_tok v3
      and v4 = Ocaml.vof_list vof_xhp_body v4
      and v5 = vof_wrap (Ocaml.vof_option vof_xhp_tag) v5
      in Ocaml.VSum (("Xhp", [ v1; v2; v3; v4; v5 ]))
  | XhpSingleton ((v1, v2, v3)) ->
      let v1 = vof_wrap vof_xhp_tag v1
      and v2 = Ocaml.vof_list vof_xhp_attribute v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("XhpSingleton", [ v1; v2; v3 ]))
and vof_xhp_attribute (v1, v2, v3) =
  let v1 = vof_xhp_attr_name v1
  and v2 = vof_tok v2
  and v3 = vof_xhp_attr_value v3
  in Ocaml.VTuple [ v1; v2; v3 ]
and vof_xhp_attr_name v = vof_wrap Ocaml.vof_string v
and vof_xhp_attr_value =
  function
  | XhpAttrString ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = Ocaml.vof_list vof_encaps v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("XhpAttrString", [ v1; v2; v3 ]))
  | XhpAttrExpr v1 ->
      let v1 = vof_brace vof_expr v1 in Ocaml.VSum (("XhpAttrExpr", [ v1 ]))
  | SgrepXhpAttrValueMvar _ -> failwith "TODO: SgrepXhpAttrValueMvar"
and vof_xhp_body =
  function
  | XhpText v1 ->
      let v1 = vof_wrap Ocaml.vof_string v1
      in Ocaml.VSum (("XhpText", [ v1 ]))
  | XhpExpr v1 ->
      let v1 = vof_brace vof_expr v1 in Ocaml.VSum (("XhpExpr", [ v1 ]))
  | XhpNested v1 ->
      let v1 = vof_xhp_html v1 in Ocaml.VSum (("XhpNested", [ v1 ]))
and vof_lvalue x = vof_expr x
and vof_argument =
  function
  | Arg v1 -> let v1 = vof_expr v1 in Ocaml.VSum (("Arg", [ v1 ]))
  | ArgRef ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_w_variable v2
      in Ocaml.VSum (("ArgRef", [ v1; v2 ]))
  | ArgUnpack ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_expr v2
      in Ocaml.VSum (("ArgUnpack", [ v1; v2 ]))
and vof_rw_variable v = vof_lvalue v
and vof_r_variable v = vof_lvalue v
and vof_w_variable v = vof_lvalue v

and vof_stmt =
  function
  | ExprStmt ((v1, v2)) ->
      let v1 = vof_expr v1
      and v2 = vof_tok v2
      in Ocaml.VSum (("ExprStmt", [ v1; v2 ]))
  | EmptyStmt v1 -> let v1 = vof_tok v1 in Ocaml.VSum (("EmptyStmt", [ v1 ]))
  | Block v1 ->
      let v1 = vof_brace (vof_list vof_stmt_and_def) v1
      in Ocaml.VSum (("Block", [ v1 ]))
  | If ((v1, v2, v3, v4, v5)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren vof_expr v2
      and v3 = vof_stmt v3
      and v4 =
        vof_list
          (fun (v1, v2, v3) ->
             let v1 = vof_tok v1
             and v2 = vof_paren vof_expr v2
             and v3 = vof_stmt v3
             in Ocaml.VTuple [ v1; v2; v3 ])
          v4
      and v5 =
        vof_option
          (fun (v1, v2) ->
             let v1 = vof_tok v1
             and v2 = vof_stmt v2
             in Ocaml.VTuple [ v1; v2 ])
          v5
      in Ocaml.VSum (("If", [ v1; v2; v3; v4; v5 ]))
  | IfColon ((v1, v2, v3, v4, v5, v6, v7, v8)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren vof_expr v2
      and v3 = vof_tok v3
      and v4 = vof_list vof_stmt_and_def v4
      and v5 = vof_list vof_new_elseif v5
      and v6 = vof_option vof_new_else v6
      and v7 = vof_tok v7
      and v8 = vof_tok v8
      in Ocaml.VSum (("IfColon", [ v1; v2; v3; v4; v5; v6; v7; v8 ]))
  | While ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren vof_expr v2
      and v3 = vof_colon_stmt v3
      in Ocaml.VSum (("While", [ v1; v2; v3 ]))
  | Do ((v1, v2, v3, v4, v5)) ->
      let v1 = vof_tok v1
      and v2 = vof_stmt v2
      and v3 = vof_tok v3
      and v4 = vof_paren vof_expr v4
      and v5 = vof_tok v5
      in Ocaml.VSum (("Do", [ v1; v2; v3; v4; v5 ]))
  | For ((v1, v2, v3, v4, v5, v6, v7, v8, v9)) ->
      let v1 = vof_tok v1
      and v2 = vof_tok v2
      and v3 = vof_for_expr v3
      and v4 = vof_tok v4
      and v5 = vof_for_expr v5
      and v6 = vof_tok v6
      and v7 = vof_for_expr v7
      and v8 = vof_tok v8
      and v9 = vof_colon_stmt v9
      in Ocaml.VSum (("For", [ v1; v2; v3; v4; v5; v6; v7; v8; v9 ]))
  | Switch ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren vof_expr v2
      and v3 = vof_switch_case_list v3
      in Ocaml.VSum (("Switch", [ v1; v2; v3 ]))
  | Foreach ((v1, v2, v3, v4, v5, v6, v7, v8)) ->
      let v1 = vof_tok v1
      and v2 = vof_tok v2
      and v3 = vof_expr v3
      and v4 = vof_option vof_tok v4
      and v5 = vof_tok v5
      and v6 = vof_foreach_pattern v6
      and v7 = vof_tok v7
      and v8 = vof_colon_stmt v8
      in Ocaml.VSum (("Foreach", [ v1; v2; v3; v4; v5; v6; v7; v8 ]))
  | Break ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_option vof_expr v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("Break", [ v1; v2; v3 ]))
  | Continue ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_option vof_expr v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("Continue", [ v1; v2; v3 ]))
  | Return ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_option vof_expr v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("Return", [ v1; v2; v3 ]))
  | Throw ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_expr v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("Throw", [ v1; v2; v3 ]))
  | Try ((v1, v2, v3, v4)) ->
      let v1 = vof_tok v1
      and v2 = vof_brace (vof_list vof_stmt_and_def) v2
      and v3 = vof_list vof_catch v3
      and v4 = vof_list vof_finally v4
      in Ocaml.VSum (("Try", [ v1; v2; v3; v4 ]))
  | Echo ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_comma_list vof_expr v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("Echo", [ v1; v2; v3 ]))
  | Globals ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_comma_list vof_global_var v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("Globals", [ v1; v2; v3 ]))
  | StaticVars ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_comma_list vof_static_var v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("StaticVars", [ v1; v2; v3 ]))
  | InlineHtml v1 ->
      let v1 = vof_wrap vof_string v1 in Ocaml.VSum (("InlineHtml", [ v1 ]))
  | Use ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_use_filename v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("Use", [ v1; v2; v3 ]))
  | Unset ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren (vof_comma_list vof_lvalue) v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("Unset", [ v1; v2; v3 ]))
  | Declare ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren (vof_comma_list vof_declare) v2
      and v3 = vof_colon_stmt v3
      in Ocaml.VSum (("Declare", [ v1; v2; v3 ]))

  | FuncDefNested v1 ->
      let v1 = vof_func_def v1 in Ocaml.VSum (("FuncDefNested", [ v1 ]))
  | ClassDefNested v1 ->
      let v1 = vof_class_def v1 in Ocaml.VSum (("ClassDefNested", [ v1 ]))

and vof_switch_case_list =
  function
  | CaseList ((v1, v2, v3, v4)) ->
      let v1 = vof_tok v1
      and v2 = vof_option vof_tok v2
      and v3 = vof_list vof_case v3
      and v4 = vof_tok v4
      in Ocaml.VSum (("CaseList", [ v1; v2; v3; v4 ]))
  | CaseColonList ((v1, v2, v3, v4, v5)) ->
      let v1 = vof_tok v1
      and v2 = vof_option vof_tok v2
      and v3 = vof_list vof_case v3
      and v4 = vof_tok v4
      and v5 = vof_tok v5
      in Ocaml.VSum (("CaseColonList", [ v1; v2; v3; v4; v5 ]))
and vof_case =
  function
  | Case ((v1, v2, v3, v4)) ->
      let v1 = vof_tok v1
      and v2 = vof_expr v2
      and v3 = vof_tok v3
      and v4 = vof_list vof_stmt_and_def v4
      in Ocaml.VSum (("Case", [ v1; v2; v3; v4 ]))
  | Default ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_tok v2
      and v3 = vof_list vof_stmt_and_def v3
      in Ocaml.VSum (("Default", [ v1; v2; v3 ]))
and vof_for_expr v = vof_comma_list vof_expr v
and vof_foreach_pattern =
  function
  | ForeachVar v1 ->
      let v1 = vof_foreach_variable v1 in Ocaml.VSum (("ForeachVar", [ v1 ]))
  | ForeachArrow ((v1, v2, v3)) ->
      let v1 = vof_foreach_pattern v1
      and v2 = vof_tok v2
      and v3 = vof_foreach_pattern v3
      in Ocaml.VSum (("ForeachArrow", [ v1; v2; v3 ]))
  | ForeachList ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren (vof_comma_list vof_list_assign) v2
      in Ocaml.VSum (("ForeachList", [ v1; v2 ]))
and vof_foreach_variable (v1, v2) =
  let v1 = vof_is_ref v1 and v2 = vof_lvalue v2 in Ocaml.VTuple [ v1; v2 ]
and vof_catch (v1, v2, v3) =
  let v1 = vof_tok v1
  and v2 =
    vof_paren
      (fun (v1, v2) ->
         let v1 = vof_fully_qualified_class_name v1
         and v2 = vof_dname v2
         in Ocaml.VTuple [ v1; v2 ])
      v2
  and v3 = vof_brace (vof_list vof_stmt_and_def) v3
  in Ocaml.VTuple [ v1; v2; v3 ]
and vof_finally (v1, v2) =
  let v1 = vof_tok v1
  and v2 = vof_brace (vof_list vof_stmt_and_def) v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_use_filename =
  function
  | UseDirect v1 ->
      let v1 = vof_wrap vof_string v1 in Ocaml.VSum (("UseDirect", [ v1 ]))
  | UseParen v1 ->
      let v1 = vof_paren (vof_wrap vof_string) v1
      in Ocaml.VSum (("UseParen", [ v1 ]))
and vof_declare (v1, v2) =
  let v1 = vof_ident v1
  and v2 = vof_static_scalar_affect v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_colon_stmt =
  function
  | SingleStmt v1 ->
      let v1 = vof_stmt v1 in Ocaml.VSum (("SingleStmt", [ v1 ]))
  | ColonStmt ((v1, v2, v3, v4)) ->
      let v1 = vof_tok v1
      and v2 = vof_list vof_stmt_and_def v2
      and v3 = vof_tok v3
      and v4 = vof_tok v4
      in Ocaml.VSum (("ColonStmt", [ v1; v2; v3; v4 ]))
and vof_new_elseif (v1, v2, v3, v4) =
  let v1 = vof_tok v1
  and v2 = vof_paren vof_expr v2
  and v3 = vof_tok v3
  and v4 = vof_list vof_stmt_and_def v4
  in Ocaml.VTuple [ v1; v2; v3; v4 ]
and vof_new_else (v1, v2, v3) =
  let v1 = vof_tok v1
  and v2 = vof_tok v2
  and v3 = vof_list vof_stmt_and_def v3
  in Ocaml.VTuple [ v1; v2; v3 ]
and
  vof_func_def {
                 f_tok = v_f_tok;
                 f_type = v_f_type;
                 f_attrs = v_f_attrs;
                 f_modifiers = v_f_modifiers;
                 f_ref = v_f_ref;
                 f_name = v_f_name;
                 f_tparams = v_f_tparams;
                 f_params = v_f_params;
                 f_return_type = v_f_return_type;
                 f_body = v_f_body;
               } =
  let bnds = [] in
  let arg = vof_brace (vof_list vof_stmt_and_def) v_f_body in
  let bnd = ("f_body", arg) in
  let bnds = bnd :: bnds in
  let arg =
    Ocaml.vof_option
      (fun (v1, v2, v3) ->
         let v1 = vof_tok v1
         and v2 = vof_option vof_tok v2
         and v3 = vof_hint_type v3
         in Ocaml.VTuple [ v1; v2; v3 ])
      v_f_return_type in
  let bnd = ("f_return_type", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_paren (vof_comma_list_dots vof_parameter) v_f_params in
  let bnd = ("f_params", arg) in
  let bnds = bnd :: bnds in

  let arg = vof_option vof_type_params v_f_tparams in
  let bnd = ("f_tparams", arg) in
  let bnds = bnd :: bnds in

  let arg = vof_ident v_f_name in
  let bnd = ("f_name", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_is_ref v_f_ref in
  let bnd = ("f_ref", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_list (vof_wrap vof_modifier) v_f_modifiers in
  let bnd = ("f_modifiers", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_option vof_attributes v_f_attrs in
  let bnd = ("f_attrs", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_function_type v_f_type in
  let bnd = ("f_type", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_tok v_f_tok in
  let bnd = ("f_tok", arg) in
  let bnds = bnd :: bnds in
  Ocaml.VDict bnds
and vof_function_type =
  function
  | FunctionRegular -> Ocaml.VSum (("FunctionRegular", []))
  | FunctionLambda -> Ocaml.VSum (("FunctionLambda", []))
  | MethodRegular -> Ocaml.VSum (("MethodRegular", []))
  | MethodAbstract -> Ocaml.VSum (("MethodAbstract", []))
and
  vof_parameter {
                  p_attrs = v_p_attrs;
                  p_modifier = v_p_modifier;
                  p_soft_type = v_p_soft_type;
                  p_type = v_p_type;
                  p_ref = v_p_ref;
                  p_name = v_p_name;
                  p_default = v_p_default;
                  p_variadic = v_p_variadic
                } =
  let bnds = [] in
  let arg = vof_option vof_static_scalar_affect v_p_default in
  let bnd = ("p_default", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_dname v_p_name in
  let bnd = ("p_name", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_is_ref v_p_ref in
  let bnd = ("p_ref", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_option vof_hint_type v_p_type in
  let bnd = ("p_type", arg) in
  let bnds = bnd :: bnds  in
  let arg = Ocaml.vof_option vof_tok v_p_soft_type in
  let bnd = ("p_soft_type", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_option (vof_wrap vof_modifier) v_p_modifier in
  let bnd = ("p_modifier", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_option vof_attributes v_p_attrs in
  let bnd = ("p_attrs", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_option vof_tok v_p_variadic in
  let bnd = ("p_variadic", arg) in
  let bnds = bnd :: bnds in
  Ocaml.VDict bnds
and vof_hint_type =
  function
  | Hint (v1, v2) ->
    let v1 = vof_class_name_or_selfparent v1 in
    let v2 = vof_option vof_type_args v2 in
    Ocaml.VSum (("Hint", [ v1; v2 ]))
  | HintArray v1 -> let v1 = vof_tok v1 in Ocaml.VSum (("HintArray", [ v1 ]))
  | HintQuestion (v1, v2) -> let v1 = vof_tok v1 in
                             let v2 = vof_hint_type v2 in
                             Ocaml.VSum (("HintQuestion", [ v1; v2]))
  | HintTuple v1 -> let v1 = vof_paren (vof_comma_list vof_hint_type) v1 in
                    Ocaml.VSum (("HintTuple", [ v1 ]))
  | HintCallback v1 ->
      let v1 =
        vof_paren
          (fun (v1, v2, v3) ->
             let v1 = vof_tok v1
             and v2 = vof_paren (vof_comma_list_dots vof_hint_type) v2
             and v3 =
               Ocaml.vof_option
                 (fun (v1, v2, v3) ->
                    let v1 = vof_tok v1
                    and v2 = vof_option vof_tok v2
                    and v3 = vof_hint_type v3
                    in Ocaml.VTuple [ v1; v2; v3 ])
                 v3
             in Ocaml.VTuple [ v1; v2; v3 ])
          v1
      in Ocaml.VSum (("HintCallback", [ v1 ]))
  | HintShape ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 =
        vof_paren
          (vof_comma_list
             (fun (v1, v2, v3) ->
                let v1 = vof_expr v1
                and v2 = vof_tok v2
                and v3 = vof_hint_type v3
                in Ocaml.VTuple [ v1; v2; v3 ]))
          v2
      in Ocaml.VSum (("HintShape", [ v1; v2 ]))
  | HintTypeConst ((v1, v2, v3)) ->
      let v1 = vof_hint_type v1
      and v2 = vof_tok v2
      and v3 = vof_hint_type v3
      in Ocaml.VSum (("HintTypeConst", [ v1; v2; v3]))
  | HintVariadic (v1, v2) ->
      let v1 = vof_tok v1 in
      let v2 = vof_option vof_hint_type v2 in
      Ocaml.VSum (("HintVariadic", [v1; v2]))


and vof_is_ref v = vof_option vof_tok v

and vof_lexical_vars (v1, v2) =
  let v1 = vof_tok v1
  and v2 = vof_paren (vof_comma_list vof_lexical_var) v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_lexical_var =
  function
  | LexicalVar ((v1, v2)) ->
      let v1 = vof_is_ref v1
      and v2 = vof_dname v2
      in Ocaml.VSum (("LexicalVar", [ v1; v2 ]))

and vof_lambda_def (v1, v2) =
  let v1 = Ocaml.vof_option vof_lexical_vars v1
  and v2 = vof_func_def v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_constraint (v1, v2) =
  let v1 = vof_tok v1 in
  let v2 = vof_hint_type v2 in
  Ocaml.VTuple [ v1; v2 ]
and vof_enum_type {
                    e_tok = v_e_tok;
                    e_base = v_e_base;
                    e_constraint = v_e_constraint;
                  } =
  let bnds = [] in
  let arg = vof_option vof_constraint v_e_constraint in
  let bnd = ("e_constraint", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_hint_type v_e_base in
  let bnd = ("e_base", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_tok v_e_tok in
  let bnd = ("e_tok", arg) in
  let bnds = bnd :: bnds in
  Ocaml.VDict bnds

and
  vof_class_def {
                  c_type = v_c_type;
                  c_name = v_c_name;
                  c_tparams = v_c_tparams;
                  c_extends = v_c_extends;
                  c_implements = v_c_implements;
                  c_body = v_c_body;
                  c_attrs = v_c_attrs;
                  c_enum_type = v_c_enum_type;
                } =
  let bnds = [] in
  let arg = vof_option vof_enum_type v_c_enum_type in
  let bnd = ("c_enum_type", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_brace (vof_list vof_class_stmt) v_c_body in
  let bnd = ("c_body", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_option vof_attributes v_c_attrs in
  let bnd = ("c_attrs", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_option vof_interface v_c_implements in
  let bnd = ("c_implements", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_option vof_extend v_c_extends in
  let bnd = ("c_extends", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_option vof_type_params v_c_tparams in
  let bnd = ("c_tparams", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_ident v_c_name in
  let bnd = ("c_name", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_class_type v_c_type in
  let bnd = ("c_type", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_class_type =
  function
  | ClassRegular v1 ->
      let v1 = vof_tok v1 in Ocaml.VSum (("ClassRegular", [ v1 ]))
  | ClassFinal ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_tok v2
      in Ocaml.VSum (("ClassFinal", [ v1; v2 ]))
  | ClassAbstract ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_tok v2
      in Ocaml.VSum (("ClassAbstract", [ v1; v2 ]))
  | ClassAbstractFinal ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_tok v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("ClassAbstractFinal", [ v1; v2; v3 ]))
  | Interface v1 ->
      let v1 = vof_tok v1 in Ocaml.VSum (("Interface", [ v1 ]))
  | Trait v1 ->
      let v1 = vof_tok v1 in Ocaml.VSum (("Trait", [ v1 ]))
  | Enum v1 ->
      let v1 = vof_tok v1 in Ocaml.VSum (("Enum", [ v1 ]))

and vof_extend (v1, v2) =
  let v1 = vof_tok v1
  and v2 = vof_fully_qualified_class_name v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_interface (v1, v2) =
  let v1 = vof_tok v1
  and v2 = vof_comma_list vof_fully_qualified_class_name v2
  in Ocaml.VTuple [ v1; v2 ]

and vof_class_stmt =
  function
  | TraitConstraint ((v1, v2, v3, v4)) ->
      let v1 = vof_tok v1
      and v2 = vof_wrap vof_trait_constraint_kind v2
      and v3 = vof_hint_type v3
      and v4 = vof_tok v4
      in Ocaml.VSum (("TraitConstraint", [ v1; v2; v3; v4 ]))
  | ClassType ((v1)) ->
      let v1 = vof_type_def v1
      in Ocaml.VSum (("ClassType", [v1]))
  | ClassConstants ((v1, v2, opt_ty, v3, v4)) ->
      let v1 = vof_option vof_tok v1
      and v2 = vof_tok v2
      and v3 = vof_comma_list vof_class_constant v3
      and v4 = vof_tok v4
      and opt_ty = vof_option vof_hint_type opt_ty
      in Ocaml.VSum (("ClassConstants", [ v1; v2; opt_ty; v3; v4 ]))
  | ClassVariables ((v1, opt_ty, v2, v3)) ->
      let v1 = vof_class_var_modifier v1
      and v2 = vof_comma_list vof_class_variable v2
      and v3 = vof_tok v3
      and opt_ty = vof_option vof_hint_type opt_ty
      in Ocaml.VSum (("ClassVariables", [ v1; opt_ty; v2; v3 ]))
  | Method v1 ->
      let v1 = vof_method_def v1 in Ocaml.VSum (("Method", [ v1 ]))

  | XhpDecl v1 ->
      let v1 = vof_xhp_decl v1 in Ocaml.VSum (("XhpDecl", [ v1 ]))
  | UseTrait (v1, v2, v3) ->
      let v1 = vof_tok v1 in
      let v2 = vof_comma_list vof_fully_qualified_class_name v2 in
      let v3 = Ocaml.vof_either vof_tok (vof_brace (vof_list vof_trait_rule)) v3
      in
      Ocaml.VSum (("UseTrait", [v1; v2; v3]))
and vof_trait_constraint_kind =
  function
  | MustExtend -> Ocaml.VSum (("MustExtend", []))
  | MustImplement -> Ocaml.VSum (("MustImplement", []))

and vof_trait_rule =
  function
  | InsteadOf ((v1, v2, v3, v4, v5, v6)) ->
      let v1 = vof_name v1
      and v2 = vof_tok v2
      and v3 = vof_ident v3
      and v4 = vof_tok v4
      and v5 = vof_comma_list vof_class_name v5
      and v6 = vof_tok v6
      in Ocaml.VSum (("InsteadOf", [ v1; v2; v3; v4; v5; v6 ]))
  | As ((v1, v2, v3, v4, v5)) ->
      let v1 =
        Ocaml.vof_either vof_ident
          (fun (v1, v2, v3) ->
             let v1 = vof_name v1
             and v2 = vof_tok v2
             and v3 = vof_ident v3
             in Ocaml.VTuple [ v1; v2; v3 ])
          v1
      and v2 = vof_tok v2
      and v3 = Ocaml.vof_list (vof_wrap vof_modifier) v3
      and v4 = Ocaml.vof_option vof_ident v4
      and v5 = vof_tok v5
      in Ocaml.VSum (("As", [ v1; v2; v3; v4; v5 ]))

and vof_class_constant (v1, v2) =
  let v1 = vof_ident v1
  and v2 = vof_option vof_static_scalar_affect v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_class_variable (v1, v2) =
  let v1 = vof_dname v1
  and v2 = vof_option vof_static_scalar_affect v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_class_var_modifier =
  function
  | NoModifiers v1 ->
      let v1 = vof_tok v1 in Ocaml.VSum (("NoModifiers", [ v1 ]))
  | VModifiers v1 ->
      let v1 = vof_list (vof_wrap vof_modifier) v1
      in Ocaml.VSum (("VModifiers", [ v1 ]))
and vof_method_def x = vof_func_def x
and vof_modifier =
  function
  | Public -> Ocaml.VSum (("Public", []))
  | Private -> Ocaml.VSum (("Private", []))
  | Protected -> Ocaml.VSum (("Protected", []))
  | Static -> Ocaml.VSum (("Static", []))
  | Abstract -> Ocaml.VSum (("Abstract", []))
  | Final -> Ocaml.VSum (("Final", []))
  | Async -> Ocaml.VSum (("Async", []))
and vof_xhp_decl =
  function
  | XhpAttributesDecl ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_comma_list vof_xhp_attribute_decl v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("XhpAttributesDecl", [ v1; v2; v3 ]))
  | XhpChildrenDecl ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_xhp_children_decl v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("XhpChildrenDecl", [ v1; v2; v3 ]))
  | XhpCategoriesDecl ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_comma_list vof_xhp_category_decl v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("XhpCategoriesDecl", [ v1; v2; v3 ]))
and vof_xhp_attribute_decl =
  function
  | XhpAttrInherit v1 ->
      let v1 = vof_wrap vof_xhp_tag v1
      in Ocaml.VSum (("XhpAttrInherit", [ v1 ]))
  | XhpAttrDecl ((v1, v2, v3, v4)) ->
      let v1 = vof_xhp_attribute_type v1
      and v2 = vof_xhp_attr_name v2
      and v3 = Ocaml.vof_option vof_xhp_value_affect v3
      and v4 = Ocaml.vof_option vof_tok v4
      in Ocaml.VSum (("XhpAttrDecl", [ v1; v2; v3; v4 ]))
and vof_xhp_attribute_type =
  function
  | XhpAttrType v1 ->
      let v1 = vof_hint_type v1 in Ocaml.VSum (("XhpAttrType", [ v1 ]))
  | XhpAttrVar v1 ->
      let v1 = vof_tok v1 in Ocaml.VSum (("XhpAttrVar", [ v1 ]))
  | XhpAttrEnum ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_brace (vof_comma_list vof_constant) v2
      in Ocaml.VSum (("XhpAttrEnum", [ v1; v2 ]))
and vof_xhp_value_affect (v1, v2) =
  let v1 = vof_tok v1 and v2 = vof_static_scalar v2 in Ocaml.VTuple [ v1; v2 ]
and vof_xhp_children_decl =
  function
  | XhpChild v1 ->
      let v1 = vof_wrap vof_xhp_tag v1 in Ocaml.VSum (("XhpChild", [ v1 ]))
  | XhpChildCategory v1 ->
      let v1 = vof_wrap vof_xhp_tag v1
      in Ocaml.VSum (("XhpChildCategory", [ v1 ]))
  | XhpChildAny v1 ->
      let v1 = vof_tok v1 in Ocaml.VSum (("XhpChildAny", [ v1 ]))
  | XhpChildEmpty v1 ->
      let v1 = vof_tok v1 in Ocaml.VSum (("XhpChildEmpty", [ v1 ]))
  | XhpChildPcdata v1 ->
      let v1 = vof_tok v1 in Ocaml.VSum (("XhpChildPcdata", [ v1 ]))
  | XhpChildSequence ((v1, v2, v3)) ->
      let v1 = vof_xhp_children_decl v1
      and v2 = vof_tok v2
      and v3 = vof_xhp_children_decl v3
      in Ocaml.VSum (("XhpChildSequence", [ v1; v2; v3 ]))
  | XhpChildAlternative ((v1, v2, v3)) ->
      let v1 = vof_xhp_children_decl v1
      and v2 = vof_tok v2
      and v3 = vof_xhp_children_decl v3
      in Ocaml.VSum (("XhpChildAlternative", [ v1; v2; v3 ]))
  | XhpChildMul ((v1, v2)) ->
      let v1 = vof_xhp_children_decl v1
      and v2 = vof_tok v2
      in Ocaml.VSum (("XhpChildMul", [ v1; v2 ]))
  | XhpChildOption ((v1, v2)) ->
      let v1 = vof_xhp_children_decl v1
      and v2 = vof_tok v2
      in Ocaml.VSum (("XhpChildOption", [ v1; v2 ]))
  | XhpChildPlus ((v1, v2)) ->
      let v1 = vof_xhp_children_decl v1
      and v2 = vof_tok v2
      in Ocaml.VSum (("XhpChildPlus", [ v1; v2 ]))
  | XhpChildParen v1 ->
      let v1 = vof_paren vof_xhp_children_decl v1
      in Ocaml.VSum (("XhpChildParen", [ v1 ]))
and vof_xhp_category_decl v = vof_wrap vof_xhp_tag v
and vof_global_var =
  function
  | GlobalVar v1 ->
      let v1 = vof_dname v1 in Ocaml.VSum (("GlobalVar", [ v1 ]))
  | GlobalDollar ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_r_variable v2
      in Ocaml.VSum (("GlobalDollar", [ v1; v2 ]))
  | GlobalDollarExpr ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_brace vof_expr v2
      in Ocaml.VSum (("GlobalDollarExpr", [ v1; v2 ]))
and vof_static_var (v1, v2) =
  let v1 = vof_dname v1
  and v2 = vof_option vof_static_scalar_affect v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_static_scalar x = vof_expr x
and vof_static_scalar_affect (v1, v2) =
  let v1 = vof_tok v1
  and v2 = vof_static_scalar v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_stmt_and_def x = vof_stmt x

and  vof_short_lambda_def {
                         sl_modifiers = v_sl_modifiers;
                         sl_params = v_sl_params;
                         sl_tok = v_sl_tok;
                         sl_body = v_sl_body
                       } =
  let bnds = [] in
  let arg = vof_short_lambda_body v_sl_body in
  let bnd = ("sl_body", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_option vof_tok v_sl_tok in
  let bnd = ("sl_tok", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_short_lambda_params v_sl_params in
  let bnd = ("sl_params", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_list (vof_wrap vof_modifier) v_sl_modifiers in
  let bnd = ("sl_modifiers", arg) in
  let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_short_lambda_params =
  function
  | SLSingleParam v1 ->
      let v1 = vof_parameter v1 in Ocaml.VSum (("SLSingleParam", [ v1 ]))
  | SLParams v1 ->
      let v1 = vof_paren (vof_comma_list_dots vof_parameter) v1
      in Ocaml.VSum (("SLParams", [ v1 ]))
  | SLParamsOmitted ->
      Ocaml.VSum (("SLParamsOmitted", []))
and vof_short_lambda_body =
  function
  | SLExpr v1 -> let v1 = vof_expr v1 in Ocaml.VSum (("SLExpr", [ v1 ]))
  | SLBody v1 ->
      let v1 = vof_brace (Ocaml.vof_list vof_stmt_and_def) v1
      in Ocaml.VSum (("SLBody", [ v1 ]))

and
  vof_constant_def {
                     cst_toks = v_cst_toks;
                     cst_name = v_cst_name;
                     cst_type = v_cst_type;
                     cst_val = v_cst_val
                   } =
  let bnds = [] in
  let arg = vof_static_scalar v_cst_val in
  let bnd = ("cst_val", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_option vof_hint_type v_cst_type in
  let bnd = ("cst_type", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_ident v_cst_name in
  let bnd = ("cst_name", arg) in
  let bnds = bnd :: bnds in
  let arg =
    match v_cst_toks with
    | (v1, v2, v3) ->
        let v1 = vof_tok v1
        and v2 = vof_tok v2
        and v3 = vof_tok v3
        in Ocaml.VTuple [ v1; v2; v3 ] in
  let bnd = ("cst_toks", arg) in
  let bnds = bnd :: bnds in
  Ocaml.VDict bnds


and vof_attribute =
  function
  | Attribute v1 ->
      let v1 = vof_wrap Ocaml.vof_string v1
      in Ocaml.VSum (("Attribute", [ v1 ]))
  | AttributeWithArgs ((v1, v2)) ->
      let v1 = vof_wrap Ocaml.vof_string v1
      and v2 = vof_paren (vof_comma_list vof_static_scalar) v2
      in Ocaml.VSum (("AttributeWithArgs", [ v1; v2 ]))
and vof_attributes v = vof_angle (vof_comma_list vof_attribute) v

and
  vof_type_def {
                 t_tok = v_t_tok;
                 t_name = v_t_name;
                 t_tparams = v_t_tparams;
                 t_tconstraint = v_t_tconstraint;
                 t_tokeq = v_t_tokeq;
                 t_kind = v_t_kind;
                 t_sc = v_t_sc
               } =
  let bnds = [] in
  let arg = vof_tok v_t_sc in
  let bnd = ("t_sc", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_type_def_kind v_t_kind in
  let bnd = ("t_kind", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_tok v_t_tokeq in
  let bnd = ("t_tokeq", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_option vof_constraint v_t_tconstraint in
  let bnd = ("t_tconstraint", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_option vof_type_params v_t_tparams in
  let bnd = ("t_tparams", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_ident v_t_name in
  let bnd = ("t_name", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_tok v_t_tok in
  let bnd = ("t_tok", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_type_def_kind =
  function
  | Alias v1 -> let v1 = vof_hint_type v1 in Ocaml.VSum (("Alias", [ v1 ]))
  | Newtype v1 ->
      let v1 = vof_hint_type v1 in Ocaml.VSum (("Newtype", [ v1 ]))
  | ClassConstType v1 ->
    let v1 = vof_option vof_hint_type v1 in Ocaml.VSum (("ClassConstType", [v1]))

and vof_namespace_use_rule =
  function
  | ImportNamespace v1 ->
      let v1 = vof_qualified_ident v1
      in Ocaml.VSum (("ImportNamespace", [ v1 ]))
  | AliasNamespace ((v1, v2, v3)) ->
      let v1 = vof_qualified_ident v1
      and v2 = vof_tok v2
      and v3 = vof_ident v3
      in Ocaml.VSum (("AliasNamespace", [ v1; v2; v3 ]))

and vof_toplevel =
  function
  | ConstantDef v1 ->
      let v1 = vof_constant_def v1 in Ocaml.VSum (("ConstantDef", [ v1 ]))
  | StmtList v1 ->
      let v1 = vof_list vof_stmt v1 in Ocaml.VSum (("StmtList", [ v1 ]))
  | FuncDef v1 ->
      let v1 = vof_func_def v1 in Ocaml.VSum (("FuncDef", [ v1 ]))
  | ClassDef v1 ->
      let v1 = vof_class_def v1 in Ocaml.VSum (("ClassDef", [ v1 ]))
  | TypeDef v1 ->
      let v1 = vof_type_def v1 in Ocaml.VSum (("TypeDef", [ v1 ]))
  | NotParsedCorrectly v1 ->
      let v1 = vof_list vof_info v1
      in Ocaml.VSum (("NotParsedCorrectly", [ v1 ]))
  | FinalDef v1 -> let v1 = vof_info v1 in Ocaml.VSum (("FinalDef", [ v1 ]))
  | NamespaceDef ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_qualified_ident v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("NamespaceDef", [ v1; v2; v3 ]))
  | NamespaceBracketDef ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = Ocaml.vof_option vof_qualified_ident v2
      and v3 = vof_brace (Ocaml.vof_list vof_toplevel) v3
      in Ocaml.VSum (("NamespaceBracketDef", [ v1; v2; v3 ]))
  | NamespaceUse ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_comma_list vof_namespace_use_rule v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("NamespaceUse", [ v1; v2; v3 ]))

and vof_program v =
  profile_code "vof_program" (fun () ->
    vof_list vof_toplevel v
  )

and vof_entity =
  function
  | FunctionE v1 ->
      let v1 = vof_func_def v1 in Ocaml.VSum (("FunctionE", [ v1 ]))
  | ClassE v1 -> let v1 = vof_class_def v1 in Ocaml.VSum (("ClassE", [ v1 ]))
  | StmtListE v1 ->
      let v1 = Ocaml.vof_list vof_stmt v1
      in Ocaml.VSum (("StmtListE", [ v1 ]))
  | ConstantE v1 ->
      let v1 = vof_constant_def v1 in Ocaml.VSum (("ConstantE", [ v1 ]))
  | TypedefE v1 ->
      let v1 = vof_type_def v1 in Ocaml.VSum (("TypedefE", [ v1 ]))
  | MethodE v1 ->
      let v1 = vof_method_def v1 in Ocaml.VSum (("MethodE", [ v1 ]))
  | ClassConstantE v1 ->
      let v1 = vof_class_constant v1
      in Ocaml.VSum (("ClassConstantE", [ v1 ]))
  | ClassVariableE ((v1, v2)) ->
      let v1 = vof_class_variable v1
      and v2 = Ocaml.vof_list vof_modifier v2
      in Ocaml.VSum (("ClassVariableE", [ v1; v2 ]))
  | XhpAttrE v1 ->
      let v1 = vof_xhp_attribute_decl v1 in Ocaml.VSum (("XhpAttrE", [ v1 ]))
  | MiscE v1 ->
      let v1 = Ocaml.vof_list vof_info v1 in Ocaml.VSum (("MiscE", [ v1 ]))

and vof_any =
  function
  | Expr v1 -> let v1 = vof_expr v1 in Ocaml.VSum (("Expr", [ v1 ]))
  | Stmt2 v1 -> let v1 = vof_stmt v1 in Ocaml.VSum (("Stmt2", [ v1 ]))
  | Toplevel v1 ->
      let v1 = vof_toplevel v1 in Ocaml.VSum (("Toplevel", [ v1 ]))
  | Program v1 -> let v1 = vof_program v1 in Ocaml.VSum (("Program", [ v1 ]))
  | Argument v1 ->
      let v1 = vof_argument v1 in Ocaml.VSum (("Argument", [ v1 ]))
  | Arguments v1 ->
      let v1 = (vof_comma_list vof_argument) v1
      in Ocaml.VSum (("Arguments", [ v1 ]))
  | Parameter v1 ->
      let v1 = vof_parameter v1 in Ocaml.VSum (("Parameter", [ v1 ]))
  | Parameters v1 ->
      let v1 = vof_paren (vof_comma_list_dots vof_parameter) v1
      in Ocaml.VSum (("Parameters", [ v1 ]))
  | ClassStmt v1 ->
      let v1 = vof_class_stmt v1 in Ocaml.VSum (("ClassStmt", [ v1 ]))
  | ClassConstant2 v1 ->
      let v1 = vof_class_constant v1
      in Ocaml.VSum (("ClassConstant2", [ v1 ]))
  | ClassVariable v1 ->
      let v1 = vof_class_variable v1
      in Ocaml.VSum (("ClassVariable", [ v1 ]))
  | Body v1 ->
      let v1 = vof_brace (Ocaml.vof_list vof_stmt_and_def) v1
      in Ocaml.VSum (("Body", [ v1 ]))
  | ListAssign v1 ->
      let v1 = vof_list_assign v1 in Ocaml.VSum (("ListAssign", [ v1 ]))
  | XhpAttribute v1 ->
      let v1 = vof_xhp_attribute v1 in Ocaml.VSum (("XhpAttribute", [ v1 ]))
  | XhpAttrValue v1 ->
      let v1 = vof_xhp_attr_value v1 in Ocaml.VSum (("XhpAttrValue", [ v1 ]))
  | XhpHtml2 v1 ->
      let v1 = vof_xhp_html v1 in Ocaml.VSum (("XhpHtml2", [ v1 ]))
  | XhpChildrenDecl2 v1 ->
      let v1 = vof_xhp_children_decl v1 in Ocaml.VSum (("XhpChildrenDecl2",
                                                        [ v1 ]))

  | Info v1 -> let v1 = vof_info v1 in Ocaml.VSum (("Info", [ v1 ]))
  | InfoList v1 ->
      let v1 = Ocaml.vof_list vof_info v1
      in Ocaml.VSum (("InfoList", [ v1 ]))
  | ColonStmt2 v1 ->
      let v1 = vof_colon_stmt v1 in Ocaml.VSum (("ColonStmt2", [ v1 ]))
  | Case2 v1 -> let v1 = vof_case v1 in Ocaml.VSum (("Case2", [ v1 ]))
  | StmtAndDefs v1 ->
      let v1 = Ocaml.vof_list vof_stmt_and_def v1
      in Ocaml.VSum (("StmtAndDefs", [ v1 ]))

  | Entity v1 -> let v1 = vof_entity v1 in Ocaml.VSum (("Entity", [ v1 ]))
  | Ident2 v1 -> let v1 = vof_ident v1 in Ocaml.VSum(("Ident2", [ v1 ]))
  | Hint2 v1 -> let v1 = vof_hint_type v1 in Ocaml.VSum (("Hint2", [ v1 ]))
